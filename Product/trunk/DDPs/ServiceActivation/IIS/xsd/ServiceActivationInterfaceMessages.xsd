<?xml version="1.0" encoding="UTF-8"?>
<!-- mTOP DDP - OM Service Activation Interface (SAI) - Copyright TeleManagement Forum 2008 -->
<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema" targetNamespace="http://www.tmforum.org/mtop/sa/xsd/sai/v1" 
xmlns:tns="http://www.tmforum.org/mtop/sa/xsd/sai/v1" 
xmlns:gen="http://www.tmforum.org/mtop/fmw/xsd/gen/v1" 
xmlns:sairsp="http://www.tmforum.org/mtop/sa/xsd/sairsp/v1" 
xmlns:saiexcpt="http://www.tmforum.org/mtop/sa/xsd/saiexcpt/v1" 
xmlns:csi="http://www.tmforum.org/mtop/sb/xsd/csi/v1" 
xmlns:nam="http://www.tmforum.org/mtop/fmw/xsd/nam/v1" 
attributeFormDefault="unqualified" elementFormDefault="qualified" version="1.0">
  <xsd:annotation>
    <xsd:documentation>
      <p>DDP: Service Activation</p>
      <p>Module: Message XSD Module</p>
      <p>Description: This module contains the XML Schema type definitions of all the mTOP Service Activation Interface (SAI) XML message structures.</p>
    </xsd:documentation>
  </xsd:annotation>
  <!-- ================ -->
  <xsd:import schemaLocation="SaResponses.xsd" namespace="http://www.tmforum.org/mtop/sa/xsd/sairsp/v1"/>
  <xsd:import schemaLocation="SaExceptions.xsd" namespace="http://www.tmforum.org/mtop/sa/xsd/saiexcpt/v1"/>
  <xsd:import schemaLocation="../../../ServiceBasic/IIS/xsd/CommonServiceInfo.xsd" namespace="http://www.tmforum.org/mtop/sb/xsd/csi/v1"/>
  <xsd:import schemaLocation="../../../Framework/IIS/xsd/GeneralDefinitions.xsd" namespace="http://www.tmforum.org/mtop/fmw/xsd/gen/v1"/>
  <xsd:import schemaLocation="../../../Framework/IIS/xsd/NamingDefinitions.xsd" namespace="http://www.tmforum.org/mtop/fmw/xsd/nam/v1"/>
  <!-- ===================== Data Types ========= -->
  <!-- === Product Info === -->
  <xsd:complexType name="ProductInfoType">
    <xsd:annotation>
      <xsd:documentation>
        <p>This data type defines the product information that in included in many of the
                SAI requests.</p>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="productName" type="nam:NamingAttributeType"/>
      <xsd:element name="productSpecificationName" type="nam:NamingAttributeType" minOccurs="0"/>
      <xsd:element name="productBundleName" type="nam:NamingAttributeType" minOccurs="0"/>
      <!-- === List of (productSpecCharacteristicRef, ProductCharacteristicValue) === -->
      <xsd:sequence minOccurs="0" maxOccurs="unbounded">
        <xsd:element name="productSpecCharacteristicRef" type="nam:NamingAttributeType" minOccurs="0"/>
        <xsd:element name="productCharacteristicValue" type="xsd:string" minOccurs="0"/>
      </xsd:sequence>
    </xsd:sequence>
  </xsd:complexType>
  <!-- === Schedules === -->
  <xsd:complexType name="PeriodicScheduleType">
    <xsd:annotation>
      <xsd:documentation>
        <p>This data type defines a periodic schedule. There is an start and optionally an end date and
			time. The availability duration indicates how long the service is available in each recurrence 
			interval. The illustration of an example periodic schedule in TMF518_SA_2 should help in the 
			understanding of this concept.</p>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="start" type="xsd:dateTime"/>
      <xsd:element name="availabilityDuration" type="xsd:duration"/>
      <xsd:element name="recurrenceInterval" type="xsd:duration"/>
      <xsd:element name="end" type="xsd:dateTime" minOccurs="0"/>
      <xsd:element name="extensionTime" type="xsd:duration" minOccurs="0" maxOccurs="unbounded">
        <xsd:annotation>
          <xsd:documentation>
            <p>Overruns shall be supported where an overrun entails one or more extensions to an 
					availability period (typically involving a higher fee). The allowable overrun is represented 
					as a sequence of extension times. The specific logic associated with the time extensions is 
					defined as part of the product characteristics and likely to vary depending on the product.</p>
            <p>The first element in the list is the first extension and so on. The number of extensions is
					is not restricted but in practice it appears that only 2 or 3 extensions would be needed.</p>
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType name="RandomScheduleType">
    <xsd:annotation>
      <xsd:documentation>
        <p>This data type defines a random schedule. It is basically a list of start times and associated
			availability times. For each start time, the services associated with a product instance are available
			for a given amount of time (this can vary per start time). The illustration of an example periodic 
			schedule in TMF518_SA_2 should help in the understanding of this concept.</p>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:sequence minOccurs="1" maxOccurs="unbounded">
        <xsd:element name="start" type="xsd:dateTime"/>
        <xsd:element name="availabilityDuration" type="xsd:duration"/>
      </xsd:sequence>
      <xsd:element name="extensionTime" type="xsd:duration" minOccurs="0" maxOccurs="unbounded">
        <xsd:annotation>
          <xsd:documentation>
            <p>Overruns shall be supported where an overrun entails one or more extensions to an 
					availability period (typically involving a higher fee). The allowable overrun is represented 
					as a sequence of extension times. The specific logic associated with the time extensions is 
					defined as part of the product characteristics and likely to vary depending on the product.</p>
            <p>The first element in the list is the first extension and so on. The number of extensions is
					is not restricted but in practice it appears that only 2 or 3 extensions would be needed.</p>
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType name="AvailabilityScheduleType">
    <xsd:annotation>
      <xsd:documentation>
        <p>The availability schedule indicates when the services associated with a product shall be 
			available. There are two kinds of schedules, i.e., periodic and random.</p>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:choice>
      <xsd:element name="periodicSchedule" type="tns:PeriodicScheduleType"/>
      <xsd:element name="randomSchedule" type="tns:RandomScheduleType"/>
    </xsd:choice>
  </xsd:complexType>
  <!-- === Root Request === -->
  <xsd:complexType name="RootRequestType">
    <xsd:annotation>
      <xsd:documentation>
        <p>This is the root request. It is extended by other request types.</p>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="vendorExtensions" type="gen:AnyListType" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            <p>Containment for all vendor extensions in</p>
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>
  <!-- === Request Info Basic === -->
  <xsd:complexType name="RequestInfoBasicType">
    <xsd:complexContent>
      <xsd:extension base="tns:RootRequestType">
        <xsd:sequence>
          <xsd:element name="productInfo" type="tns:ProductInfoType">
            <xsd:annotation>
              <xsd:documentation>
                <p>This parameter identifies the product information associated with the
						request. The target OS will translate the product information to service
						level information and then perform the requested action.</p>
              </xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="subscriberRefList" type="nam:NamingAttributeType" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>
                <p>This parameter provides a list of the subscribers associated with the request.
                        The subscriberRefList applies to the given product instance as opposed to being
                        applied to a subset of the CFSs associated with the product instance.</p>
              </xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="userRefList" type="nam:NamingAttributeType" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>
                <p>This parameter provides a list of the users associated with the request.
                        It is assumed that all on the userRefList apply to the given product instance as
                        opposed to being applied to a subset of the CFSs associated with the product instance.</p>
              </xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="sapRefList" type="nam:NamingAttributeType" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>
                <p>This parameter provides a list of the SAPs associated with the request.</p>
              </xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <!-- === Request Info - Service Order Aware === -->
  <xsd:complexType name="RequestInfoSOAwareType">
    <xsd:sequence>
      <xsd:annotation>
        <xsd:documentation>
          <p>The following parameters are used in service order aware requests:</p>
          <p>requestedCompletionDate – the date and time at which the requesting OS has requested 
					that execution of the service order be complete. The target OS will take this as input 
					to its scheduling process. The target OS will provide the requesting OS with an expectedCompletionDate 
					which indicates when the target OS thinks it can complete the execution of the service order. The 
					target OS is allowed to complete execution of the service order before the requestedCompletionDate. 
					This parameter is only used in the order aware version of the interface.</p>
          <p>priority – this attribute allows the request to specify a priority for execution of the service 
					request. This attribute is a positive integer.</p>
          <p>purchaseOrder – identifies the associated customer order.</p>
          <p>validFor – the date and time for which this request is valid. If the request is not fulfilled 
					by the provided date and time, the service order process will automatically be aborted by the target OS.</p>
        </xsd:documentation>
      </xsd:annotation>
      <xsd:element name="requestedCompletionDate" type="xsd:dateTime"/>
      <xsd:element name="priority" type="xsd:integer"/>
      <xsd:element name="purchaseOrder" type="xsd:string"/>
      <xsd:element name="validFor" type="xsd:dateTime"/>
    </xsd:sequence>
  </xsd:complexType>
  <!-- === Feasibility Check === -->
  <!-- ===================== Feasibility Check Request Message ========= -->
  <xsd:element name="feasibilityCheckRequest">
    <xsd:annotation>
      <xsd:documentation>
        <p>This operation verifies the feasibility of provisioning and activating the CFSs in
                support of a product instance. If the operation is successful, CFS objects are created
                and placed in the FeasibilityChecked state and the requesting OS is informed that
                its request is feasible, but nothing is reserved.</p>
        <p>Pre-condition(s): The CFSs supporting the product instance do not yet exist.</p>
        <p>Post-condition(s):</p>
        <p>In case of success:</p>
        <p>The CFS(s) associated with the product instance are all in the FeasibilityChecked state.</p>
        <p>In case of failure:</p>
        <p>In the case of an atomic request, all traces of the CFSs have been deleted. </p>
        <p>Support for "best effort" is not recommended for this operation since this
                operation is fundamentally an atomic request.</p>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>
      <xsd:sequence>
        <xsd:element name="feasibilityCheckRequestInput" type="tns:RequestInfoBasicType"/>
      </xsd:sequence>
    </xsd:complexType>
  </xsd:element>
  <!-- ===================== Feasibility Check Response Messages ========= -->
  <xsd:element name="feasibilityCheckResponse">
    <xsd:annotation>
      <xsd:documentation>
        <p>This type covers the various responses to the feasibilityCheck request.</p>
		<p>Multiple responses to this request are possible, unless there is an exception.
		The expectation is to have on instance of the initialResponse and beginProcessingEvent and
		the possibility of multiple instances of the success and failure responses. There will
		be an indication in the header of the last response which can be either a success or failure
		response.</p>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>
      <xsd:choice maxOccurs="unbounded">
	  	<!-- === Success responses === -->
        <xsd:element name="initialResponse" type="sairsp:InitialResponseType"/>
        <xsd:element name="beginProcessingEvent" type="sairsp:BeginProcessingEventType"/>
        <xsd:element name="cfsCreation" type="sairsp:CfsCreationEventType"/>
		<!-- === Partial failure responses which are not to be confused with an exception that 
		stops the request === -->
		<xsd:element name="serviceCreationFailureEvent" type="saiexcpt:ServiceCreationFailureEventType"/>
      </xsd:choice>
    </xsd:complexType>
  </xsd:element>
  <!-- ===================== Feasibility Check Exceptions ========= -->
  <xsd:element name="feasibilityCheckException">
    <xsd:annotation>
      <xsd:documentation>
        <p>This type defines the allowable exceptions to the feasibility check operation.</p>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>
      <xsd:choice>
        <xsd:element name="basicFailureEvent" type="saiexcpt:BasicFailureEventType"/>
      </xsd:choice>
    </xsd:complexType>
  </xsd:element>
  <!-- === Design === -->
  <!-- ===================== Design Request Message ========= -->
  <xsd:element name="designRequest">
    <xsd:annotation>
      <xsd:documentation>
        <p>This operation designs the CFSs in support of a product instance. If feasibility has 
				not already been checked, it will be checked as part of this operation. The target OS will 
				create, but not start, a service order for the overall request. The target OS will also 
				create, but not start, RFSs orders for the CFSs associated with the product. It should be 
				emphasized that only the "overall" service order (but not the RFS orders) can be retrieved
				over the SAI.</p>
        <p>Pre-condition(s): The CFSs supporting the product instance either do not yet exist or
                are in the FeasibilityChecked or Designed state. </p>
        <p>Post-condition(s):</p>
        <p>In case of success:</p>
        <p>The CFS(s) associated with the product instance are all in the Designed state.</p>
        <p>In case of failure:</p>
        <p>In the case of an atomic request, all CFS(s) have all been returned to their original state
                before the service request.</p>
        <p>In the case of best effort, the CFSs associated with the product instance remain in their
                current state. No rollback is attempted in this case.</p>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>
      <xsd:sequence>
        <xsd:element name="basicInput" type="tns:RequestInfoBasicType"/>
        <xsd:element name="soaInput" type="tns:RequestInfoSOAwareType"/>
      </xsd:sequence>
    </xsd:complexType>
  </xsd:element>
  <!-- ===================== Design Response Messages ========= -->
  <xsd:element name="designResponse">
    <xsd:annotation>
      <xsd:documentation>
        <p>This type covers the various responses to the design request.</p>
		<p>Multiple responses to this request are possible, unless there is an exception.
		The expectation is to have on instance of the initialResponse and beginProcessingEvent and
		the possibility of multiple instances of the success and failure responses. There will
		be an indication in the header of the last response which can be either a success or failure
		response.</p>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>
      <xsd:choice maxOccurs="unbounded">
	  	<!-- === Success responses === -->
        <xsd:element name="initialResponse" type="sairsp:InitialResponseType"/>
        <xsd:element name="beginProcessingEvent" type="sairsp:BeginProcessingEventType"/>
        <xsd:element name="cfsCreation" type="sairsp:CfsCreationEventType"/>
        <xsd:element name="cfsStateChange" type="sairsp:CfsStateChangeEventType"/>
		<!-- === Partial failure responses which are not to be confused with an exception that 
		stops the request === -->
		<xsd:element name="serviceCreationFailureEvent" type="saiexcpt:ServiceCreationFailureEventType"/>
        <xsd:element name="serviceStateTransitionFailureEvent" type="saiexcpt:ServiceStateTransitionFailureEventType"/>
      </xsd:choice>
    </xsd:complexType>
  </xsd:element>
  <!-- ===================== Design Exceptions ========= -->
  <xsd:element name="designException">
    <xsd:annotation>
      <xsd:documentation>
        <p>This type defines the allowable exceptions to the design operation.</p>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>
      <xsd:choice>
        <xsd:element name="basicFailureEvent" type="saiexcpt:BasicFailureEventType"/>
      </xsd:choice>
    </xsd:complexType>
  </xsd:element>
  <!-- === Reserve === -->
  <!-- ===================== Reserve Request Messages ========= -->
  <!-- === Reserve Request === -->
  <xsd:element name="reserveRequest">
    <xsd:annotation>
      <xsd:documentation>
        <p>This operation reserves the CFSs in support of a product instance.</p>
        <p>If feasibility check and design have not yet been done for the CFSs supporting the 
				given product instance, both will be done as part of this operation.</p>
        <p>The target OS will not go forward with the reservation unless and until the requesting 
				OS commits. If the commit is not indicated in the initial request, the requesting OS will 
				need to commit via the amend operation before the expiring time.</p>
        <p>When this operation is complete, the requesting OS confirmation of their requested 
				activation time and/or termination time. Alternately, if the target OS cannot meet the 
				requested time(s), it will reject the request. The possibility of negotiation concerning 
				activation/termination times is for further study.</p>
        <p>Pre-condition(s): The CFSs supporting the product instance either do not yet exist 
				or are in the FeasibilityChecked, Designed or Reserved state.  </p>
        <p>Post-condition(s):</p>
        <p>In case of success:</p>
        <p>The CFS(s) associated with the product instance are all in the Reserved state.</p>
        <p>In case of failure:</p>
        <p>In the case of an atomic request, all CFS(s) have all been returned to their original state
                before the service request.</p>
        <p>In the case of best effort, the CFSs associated with the product instance remain in their
                current state. No rollback is attempted in this case.</p>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>
      <xsd:sequence>
        <xsd:element name="basicInput" type="tns:RequestInfoBasicType"/>
        <xsd:element name="soaInput" type="tns:RequestInfoSOAwareType"/>
        <xsd:element name="expiringTime" type="xsd:dateTime">
          <xsd:annotation>
            <xsd:documentation>
              <p>This is the date and time by which an uncommitted reservation will be canceled. 
						A committed reservation request always contains an empty expiringTime value.</p>
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>
        <xsd:element name="productAvailabilitySchedule" type="tns:AvailabilityScheduleType">
          <xsd:annotation>
            <xsd:documentation>
              <p>This is the schedule for when the product shall be made available. 
						The target OS process needs to map this schedule into a transition schedule for 
						one or more of the associated CFSs.</p>
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>
        <xsd:element name="commit" type="xsd:boolean">
          <xsd:annotation>
            <xsd:documentation>
              <p>This parameter indicates whether or not the requesting OS has committed to 
						the reservation. If the requesting OS does not commit in the initial request, 
						it must commit to the reservation using the amend operation before the expiringTime;
						otherwise, the target OS will cancel the request.</p>
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>
        <xsd:element name="desiredState" type="xsd:string">
          <xsd:annotation>
            <xsd:documentation>
              <p>This parameter indicates the desired initial transition when the reservation 
						period is over. There are two choices, i.e., Provisioned_Inactive or Provisioned_Active.</p>
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>
      </xsd:sequence>
    </xsd:complexType>
  </xsd:element>
  <!-- === Amend === -->
  <xsd:element name="amendRequest">
    <xsd:annotation>
      <xsd:documentation>
        <p>This operation is used by the requesting OS to confirm that it wants to go ahead with the reservation. 
		It is only used when “commit” is set to false in the initial reserve request. If a commit is not made in 
		either the initial reserve request or a subsequent amend request before the expiringTime, the target OS will 
		cancel the reserve request. </p>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>
      <xsd:sequence>
        <xsd:element name="serviceRequestID" type="xsd:string">
          <xsd:annotation>
            <xsd:documentation>
              This is the request ID from the initial reservation request. It is required so that the target OS
			  can correlate the amend operation with the proper reserve request.  
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>
      </xsd:sequence>
    </xsd:complexType>
  </xsd:element>
  <!-- ===================== Reserve Response Messages ========= -->
  <!-- === Reserve Response === -->
  <xsd:element name="reserveResponse">
    <xsd:annotation>
      <xsd:documentation>
        <p>This type covers the various responses to the reserve request.</p>
		<p>Multiple responses to this request are possible, unless there is an exception.
		The expectation is to have on instance of the initialResponse and beginProcessingEvent and
		the possibility of multiple instances of the success and failure responses. There will
		be an indication in the header of the last response which can be either a success or failure
		response.</p>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>
      <xsd:choice maxOccurs="unbounded">
	    <!-- === Success responses === -->
        <xsd:element name="initialResponse" type="sairsp:InitialResponseType"/>
        <xsd:element name="beginProcessingEvent" type="sairsp:BeginProcessingEventType"/>
        <xsd:element name="cfsCreation" type="sairsp:CfsCreationEventType"/>
        <xsd:element name="cfsStateChange" type="sairsp:CfsStateChangeEventType"/>
		<!-- === Partial failure responses which are not to be confused with an exception that 
		stops the request === -->
		<xsd:element name="serviceCreationFailureEvent" type="saiexcpt:ServiceCreationFailureEventType"/>
        <xsd:element name="serviceStateTransitionFailureEvent" type="saiexcpt:ServiceStateTransitionFailureEventType"/>
      </xsd:choice>
    </xsd:complexType>
  </xsd:element>
  <!-- === Amend Response === -->
  <xsd:element name="amendResponse">
    <xsd:annotation>
      <xsd:documentation>
        <p>This is a positive or negative acknowledgment with no parameters. In the case, of a negative 
		acknowledgment, a reason is also given, e.g., “expiringTime has passed”..</p>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>
      <xsd:sequence>
        <xsd:element name="ack" type="xsd:boolean">
          <xsd:annotation>
            <xsd:documentation>
              <p>This is an indication of whether or not the amend request was accepted.</p>
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>
        <xsd:element name="nackReason" type="xsd:string">
          <xsd:annotation>
            <xsd:documentation>
              <p>In the case where a negative acknowledgment is provided, the target OS may provide a reason. The 
			  most common reason would be "the expiringTime has passed."</p>
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>
      </xsd:sequence>
    </xsd:complexType>
  </xsd:element>
  <!-- ===================== Reserve Exceptions ========= -->
  <!-- === Reserve Request Exceptions === -->
  <xsd:element name="reserveException">
    <xsd:annotation>
      <xsd:documentation>
        <p>This type defines the allowable exceptions to the reserve operation.</p>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>
      <xsd:choice>
        <xsd:element name="basicFailureEvent" type="saiexcpt:BasicFailureEventType"/>
      </xsd:choice>
    </xsd:complexType>
  </xsd:element>
  <!-- === Amend Exceptions === -->
  <xsd:element name="amendException">
    <xsd:annotation>
      <xsd:documentation>
        <p>This type defines the allowable exceptions to the amend operation.</p>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>
      <!-- XML is a bit awkward here. It will not allow just an element within a complexType.
		We could use a sequence with one element or a choice with only one possibility. Decided to
		use choice to align with the format of the other exceptions. -->
      <xsd:choice>
        <xsd:element name="basicFailureEvent" type="saiexcpt:BasicFailureEventType"/>
      </xsd:choice>
    </xsd:complexType>
  </xsd:element>
  <!-- === Provision === -->
  <!-- ===================== Provision Request Message ========= -->
  <xsd:element name="provisionRequest">
    <xsd:annotation>
      <xsd:documentation>
        <p>This operation provisions the CFSs in support of a product instance.</p>
        <p>If feasibility check and design have not yet been done for the CFSs supporting 
				the given product instance, both will be done as part of this operation.</p>
        <p>When this request is complete, each CFS (associated with the product instance) 
				shall be in the Provisioned_Inactive state with all associated RFSs (and subtending 
				resources) configured and allocated to the appropriate CFS. At this point, the CFSs 
				have not yet been activated for use by the customer.</p>
        <p>Pre-condition(s): The CFSs supporting the product instance do not yet exist or 
				are in the FeasibilityChecked, Designed, Reserved (either Reserved-Committed or 
				Reserved-Uncommitted) or Provisioned_Inactive state.</p>
        <p>Post-condition(s):</p>
        <p>In case of success:</p>
        <p>The CFS(s) associated with the product instance are all in the Provisioned_Inactive state.</p>
        <p>In case of failure:</p>
        <p>In the case of an atomic request, all CFS(s) have all been returned to their original state
                before the service request.</p>
        <p>In the case of best effort, the CFSs associated with the product instance remain in their
                current state. No rollback is attempted in this case.</p>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>
      <xsd:sequence>
        <xsd:element name="basicInput" type="tns:RequestInfoBasicType"/>
        <xsd:element name="soaInput" type="tns:RequestInfoSOAwareType"/>
      </xsd:sequence>
    </xsd:complexType>
  </xsd:element>
  <!-- ===================== Provision Response Messages ========= -->
  <xsd:element name="provisionResponse">
    <xsd:annotation>
      <xsd:documentation>
        <p>This type covers the various responses to the provision request.</p>
		<p>Multiple responses to this request are possible, unless there is an exception.
		The expectation is to have on instance of the initialResponse and beginProcessingEvent and
		the possibility of multiple instances of the success and failure responses. There will
		be an indication in the header of the last response which can be either a success or failure
		response.</p>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>
      <xsd:choice maxOccurs="unbounded">
	   	<!-- === Success responses === -->
        <xsd:element name="initialResponse" type="sairsp:InitialResponseType"/>
        <xsd:element name="beginProcessingEvent" type="sairsp:BeginProcessingEventType"/>
        <xsd:element name="cfsCreation" type="sairsp:CfsCreationEventType"/>
        <xsd:element name="cfsStateChange" type="sairsp:CfsStateChangeEventType"/>
		<!-- === Partial failure responses which are not to be confused with an exception that 
		stops the request === -->
		<xsd:element name="serviceCreationFailureEvent" type="saiexcpt:ServiceCreationFailureEventType"/>
        <xsd:element name="serviceStateTransitionFailureEvent" type="saiexcpt:ServiceStateTransitionFailureEventType"/>
      </xsd:choice>
    </xsd:complexType>
  </xsd:element>
  <!-- ===================== Provision Exceptions ========= -->
  <xsd:element name="provisionException">
    <xsd:annotation>
      <xsd:documentation>
        <p>This type defines the allowable exceptions to the provision operation.</p>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>
      <xsd:choice>
        <xsd:element name="basicFailureEvent" type="saiexcpt:BasicFailureEventType"/>
      </xsd:choice>
    </xsd:complexType>
  </xsd:element>
  <!-- === Activate === -->
  <!-- ===================== Activate Request Message ========= -->
  <xsd:element name="activateRequest">
    <xsd:annotation>
      <xsd:documentation>
        <p>This operation activates the CFSs in support of a product instance.</p>
        <p>If feasibility check, design and provisioning have not yet been done for the CFSs 
				supporting the given product instance, all will be done as part of this operation.</p>
        <p>When this request is complete, each CFS (associated with the product instance) shall 
				be in the Provisioned_Active state with all associated RFSs (and subtending resources) 
				configured and allocated to the appropriate CFS. At this point, the CFSs have been 
				activated for use by the customer.</p>
        <p>Pre-condition(s): The CFSs supporting the product instance either do not yet exist 
				or are in the FeasibilityChecked, Designed, Reserved (either Reserved-Committed or 
				Reserved-Uncommitted), Provisioned_Inactive, Provisioned_Active state or Terminated.</p>
        <p>Post-condition(s):</p>
        <p>In case of success:</p>
        <p>The CFS(s) associated with the product instance are all in the Provisioned_Active state.</p>
        <p>In case of failure:</p>
        <p>In the case of an atomic request, all CFS(s) have all been returned to their original state
                before the service request.</p>
        <p>In the case of best effort, the CFSs associated with the product instance remain in their
                current state. No rollback is attempted in this case.</p>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>
      <xsd:sequence>
        <xsd:element name="basicInput" type="tns:RequestInfoBasicType"/>
        <xsd:element name="soaInput" type="tns:RequestInfoSOAwareType"/>
        <xsd:element name="cfsCurrentState" type="xsd:string">
          <xsd:annotation>
            <xsd:documentation>
              <p>The target OS should check that each CFS is in the CFS state indicated in this 
						parameter before performing the request. If not, an exception should be raised. 
						This parameter can be used (for example) when the requesting OS only wants a transition 
						to Provisioned_Active where the state must be Provisioned_Inactive (basically a 
						suspend operation).</p>
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>
      </xsd:sequence>
    </xsd:complexType>
  </xsd:element>
  <!-- ===================== Activate Response Messages ========= -->
  <xsd:element name="activateResponse">
    <xsd:annotation>
      <xsd:documentation>
        <p>This type covers the various responses to the activate request.</p>
		<p>Multiple responses to this request are possible, unless there is an exception.
		The expectation is to have on instance of the initialResponse and beginProcessingEvent and
		the possibility of multiple instances of the success and failure responses. There will
		be an indication in the header of the last response which can be either a success or failure
		response.</p>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>
      <xsd:choice maxOccurs="unbounded">
	  	<!-- === Success responses === -->
        <xsd:element name="initialResponse" type="sairsp:InitialResponseType"/>
        <xsd:element name="beginProcessingEvent" type="sairsp:BeginProcessingEventType"/>
        <xsd:element name="cfsCreation" type="sairsp:CfsCreationEventType"/>
        <xsd:element name="cfsStateChange" type="sairsp:CfsStateChangeEventType"/>
		<!-- === Partial failure responses which are not to be confused with an exception that 
		stops the request === -->
		<xsd:element name="serviceCreationFailureEvent" type="saiexcpt:ServiceCreationFailureEventType"/>
        <xsd:element name="serviceStateTransitionFailureEvent" type="saiexcpt:ServiceStateTransitionFailureEventType"/>
      </xsd:choice>
    </xsd:complexType>
  </xsd:element>
  <!-- ===================== Activate Exceptions ========= -->
  <xsd:element name="activateException">
    <xsd:annotation>
      <xsd:documentation>
        <p>This type defines the allowable exceptions to the activate operation.</p>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>
      <xsd:choice>
        <xsd:element name="basicFailureEvent" type="saiexcpt:BasicFailureEventType"/>
      </xsd:choice>
    </xsd:complexType>
  </xsd:element>
  <!-- === Dectivate === -->
  <!-- ===================== Dectivate Request Message ========= -->
  <xsd:element name="deactivateRequest">
    <xsd:annotation>
      <xsd:documentation>
        <p>This operation deactivates the CFSs in support of a product instance. 
				It is does the opposite of the activate operation.</p>
        <p>When this request is complete, each CFS (associated with the product instance) shall 
				be in the Provisioned_Inactive state with all associated RFSs (and subtending resources) 
				configured and allocated to the appropriate CFS. At this point, the CFSs are not activated 
				for use by the customer.</p>
        <p>Pre-condition(s): The CFSs supporting the product instance should be in the 
				Provisioned_Active state.</p>
        <p>Post-condition(s):</p>
        <p>In case of success:</p>
        <p>The CFS(s) associated with the product instance are all in the Provisioned_Inactive state.</p>
        <p>In case of failure:</p>
        <p>In the case of an atomic request, all CFS(s) have all been returned to their original state
                before the service request.</p>
        <p>In the case of best effort, the CFSs associated with the product instance remain in their
                current state. No rollback is attempted in this case.</p>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>
      <xsd:sequence>
        <xsd:element name="rootRequest" type="tns:RootRequestType"/>
        <xsd:element name="productName" type="nam:NamingAttributeType"/>
        <xsd:element name="soaInput" type="tns:RequestInfoSOAwareType"/>
      </xsd:sequence>
    </xsd:complexType>
  </xsd:element>
  <!-- ===================== Dectivate Response Messages ========= -->
  <xsd:element name="deactivateResponse">
    <xsd:annotation>
      <xsd:documentation>
        <p>This type covers the various responses to the deactivate request.</p>
		<p>Multiple responses to this request are possible, unless there is an exception.
		The expectation is to have on instance of the initialResponse and beginProcessingEvent and
		the possibility of multiple instances of the success and failure responses. There will
		be an indication in the header of the last response which can be either a success or failure
		response.</p>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>
      <xsd:choice maxOccurs="unbounded">
	  	<!-- === Success responses === -->
        <xsd:element name="initialResponse" type="sairsp:InitialResponseType"/>
        <xsd:element name="beginProcessingEvent" type="sairsp:BeginProcessingEventType"/>
        <xsd:element name="cfsStateChange" type="sairsp:CfsStateChangeEventType"/>
		<!-- === Partial failure responses which are not to be confused with an exception that 
		stops the request === -->
		<xsd:element name="serviceStateTransitionFailureEvent" type="saiexcpt:ServiceStateTransitionFailureEventType"/>
      </xsd:choice>
    </xsd:complexType>
  </xsd:element>
  <!-- ===================== Deactivate Exceptions ========= -->
  <xsd:element name="deactivateException">
    <xsd:annotation>
      <xsd:documentation>
        <p>This type defines the allowable exceptions to the deactivate operation.</p>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>
      <xsd:choice>
        <xsd:element name="basicFailureEvent" type="saiexcpt:BasicFailureEventType"/>
      </xsd:choice>
    </xsd:complexType>
  </xsd:element>
  <!-- === Terminate === -->
  <!-- ===================== Terminate Request Message ========= -->
  <xsd:element name="terminateRequest">
    <xsd:annotation>
      <xsd:documentation>
        <p>This operation terminates the CFSs in support of a product instance.</p>
        <p>When this request is complete, each CFS (associated with the product instance) shall 
				be in the Terminated state. The RFSs (that once supported the CFSs) are disassociated 
				from the CFSs and made available for use in other situations.</p>
        <p>Pre-condition(s): The CFSs supporting the product instance should be in the Provisioned_Inactive state.</p>
        <p>Post-condition(s):</p>
        <p>In case of success:</p>
        <p>The CFS(s) associated with the product instance are all in the Terminated state.</p>
        <p>In case of failure:</p>
        <p>In the case of an atomic request, all CFS(s) have all been returned to their original state
                before the service request.</p>
        <p>In the case of best effort, the CFSs associated with the product instance remain in their
                current state. No rollback is attempted in this case.</p>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>
      <xsd:sequence>
        <xsd:element name="rootRequest" type="tns:RootRequestType"/>
        <xsd:element name="productName" type="nam:NamingAttributeType"/>
        <xsd:element name="soaInput" type="tns:RequestInfoSOAwareType"/>
      </xsd:sequence>
    </xsd:complexType>
  </xsd:element>
  <!-- ===================== Terminate Response Messages ========= -->
  <xsd:element name="terminateResponse">
    <xsd:annotation>
      <xsd:documentation>
        <p>This type covers the various responses to the terminate request.</p>
		<p>Multiple responses to this request are possible, unless there is an exception.
		The expectation is to have on instance of the initialResponse and beginProcessingEvent and
		the possibility of multiple instances of the success and failure responses. There will
		be an indication in the header of the last response which can be either a success or failure
		response.</p>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>
      <xsd:choice maxOccurs="unbounded">
	  	<!-- === Success responses === -->
        <xsd:element name="initialResponse" type="sairsp:InitialResponseType"/>
        <xsd:element name="beginProcessingEvent" type="sairsp:BeginProcessingEventType"/>
        <xsd:element name="cfsStateChange" type="sairsp:CfsStateChangeEventType"/>
		<!-- === Partial failure responses which are not to be confused with an exception that 
		stops the request === -->
		<xsd:element name="serviceStateTransitionFailureEvent" type="saiexcpt:ServiceStateTransitionFailureEventType"/>
      </xsd:choice>
    </xsd:complexType>
  </xsd:element>
  <!-- ===================== Terminate Exceptions ========= -->
  <xsd:element name="terminateException">
    <xsd:annotation>
      <xsd:documentation>
        <p>This type defines the allowable exceptions to the terminate operation.</p>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>
      <xsd:choice>
        <xsd:element name="basicFailureEvent" type="saiexcpt:BasicFailureEventType"/>
      </xsd:choice>
    </xsd:complexType>
  </xsd:element>
  <!-- === Retire === -->
  <!-- ===================== Retire Request Message ========= -->
  <xsd:element name="retireRequest">
    <xsd:annotation>
      <xsd:documentation>
        <p>This operation deletes the CFS objects related to a product instance.</p>
        <p>When this request is complete, all the CFS objects that where once associated with 
				the product instance are deleted from the target OS.</p>
        <p>Pre-condition(s): The CFSs supporting the product instance should be in the Terminated state.</p>
        <p>Post-condition(s):</p>
        <p>In case of success:</p>
        <p>The CFS(s) associated with the product instance are all deleted.</p>
        <p>In case of failure:</p>
        <p>In the case of an atomic request, all CFS(s) have all been returned to their original state
                before the service request.</p>
        <p>In the case of best effort, the CFSs associated with the product instance remain in their
                current state. No rollback is attempted in this case.</p>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>
      <xsd:sequence>
        <xsd:element name="rootRequest" type="tns:RootRequestType"/>
        <xsd:element name="productName" type="nam:NamingAttributeType"/>
        <xsd:element name="soaInput" type="tns:RequestInfoSOAwareType"/>
      </xsd:sequence>
    </xsd:complexType>
  </xsd:element>
  <!-- ===================== Retire Response Messages ========= -->
  <xsd:element name="retireResponse">
    <xsd:annotation>
      <xsd:documentation>
        <p>This type covers the various responses to the retire request.</p>
		<p>Multiple responses to this request are possible, unless there is an exception.
		The expectation is to have on instance of the initialResponse and beginProcessingEvent and
		the possibility of multiple instances of the success and failure responses. There will
		be an indication in the header of the last response which can be either a success or failure
		response.</p>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>
      <xsd:choice maxOccurs="unbounded">
	  	<!-- === Success responses === -->
        <xsd:element name="initialResponse" type="sairsp:InitialResponseType"/>
        <xsd:element name="beginProcessingEvent" type="sairsp:BeginProcessingEventType"/>
        <xsd:element name="cfsDeleteEvent" type="sairsp:CfsDeletionEventType"/>
		<!-- === Partial failure responses which are not to be confused with an exception that 
		stops the request === -->
		<xsd:element name="serviceDeletionFailureEvent" type="saiexcpt:ServiceDeletionFailureEventType"/>
      </xsd:choice>
    </xsd:complexType>
  </xsd:element>
  <!-- ===================== Retire Exceptions ========= -->
  <xsd:element name="retireException">
    <xsd:annotation>
      <xsd:documentation>
        <p>This type defines the allowable exceptions to the retire operation.</p>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>
      <xsd:choice>
        <xsd:element name="basicFailureEvent" type="saiexcpt:BasicFailureEventType"/>
      </xsd:choice>
    </xsd:complexType>
  </xsd:element>
  <!-- === Cancel === -->
  <!-- ===================== Cancel Request Message ========= -->
  <xsd:element name="cancelRequest">
    <xsd:annotation>
      <xsd:documentation>
        <p>This operation cancels the CFS objects related to a product instance.</p>
        <p>When this request is complete, all the CFS objects that where once associated with the 
				product instance are deleted from the target OS.</p>
        <p>This operation is very similar to retire, except cancel is used when no RFSs have been 
				allocated to the CFSs in support of a product instance.</p>
        <p>Pre-condition(s): The CFSs supporting the product instance should be in the 
				Feasibility Checked, Designed or Reserved state. </p>
        <p>Post-condition(s):</p>
        <p>In case of success:</p>
        <p>The CFS(s) associated with the product instance are all deleted.</p>
        <p>In case of failure:</p>
        <p>In the case of an atomic request, all CFS(s) have all been returned to their original state
                before the service request.</p>
        <p>In the case of best effort, the CFSs associated with the product instance remain in their
                current state. No rollback is attempted in this case.</p>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>
      <xsd:sequence>
        <xsd:element name="rootRequest" type="tns:RootRequestType"/>
        <xsd:element name="productName" type="nam:NamingAttributeType"/>
        <xsd:element name="soaInput" type="tns:RequestInfoSOAwareType"/>
      </xsd:sequence>
    </xsd:complexType>
  </xsd:element>
  <!-- ===================== Cancel Response Messages ========= -->
  <xsd:element name="cancelResponse">
    <xsd:annotation>
      <xsd:documentation>
        <p>This type covers the various responses to the retire request.</p>
		<p>Multiple responses to this request are possible, unless there is an exception.
		The expectation is to have on instance of the initialResponse and beginProcessingEvent and
		the possibility of multiple instances of the success and failure responses. There will
		be an indication in the header of the last response which can be either a success or failure
		response.</p>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>
      <xsd:choice maxOccurs="unbounded">
	  	<!-- === Success responses === -->
        <xsd:element name="initialResponse" type="sairsp:InitialResponseType"/>
        <xsd:element name="beginProcessingEvent" type="sairsp:BeginProcessingEventType"/>
        <xsd:element name="cfsDeleteEvent" type="sairsp:CfsDeletionEventType"/>
		<!-- === Partial failure responses which are not to be confused with an exception that 
		stops the request === -->
		<xsd:element name="serviceDeletionFailureEvent" type="saiexcpt:ServiceDeletionFailureEventType"/>
      </xsd:choice>
    </xsd:complexType>
  </xsd:element>
  <!-- ===================== Cancel Exceptions ========= -->
  <xsd:element name="cancelException">
    <xsd:annotation>
      <xsd:documentation>
        <p>This type defines the allowable exceptions to the cancel operation.</p>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>
      <xsd:choice>
        <xsd:element name="basicFailureEvent" type="saiexcpt:BasicFailureEventType"/>
      </xsd:choice>
    </xsd:complexType>
  </xsd:element>
  <!-- === Test === -->
  <!-- ===================== Test Request Message ========= -->
  <xsd:element name="testRequest">
    <xsd:annotation>
      <xsd:documentation>
        <p>For an existing product instance, the target OS determines whether the CFSs and SAPs 
				are currently able to support service.</p>
        <p>For this version of the operation, the response will be very simple (just success or 
				failure). In future releases, the operation may be defined to provide more detailed 
				responses that indicate what CFSs and/or SAPs have failed and the reason for failure.</p>
        <p>Pre-condition(s): The CFSs supporting the product instance should be in the 
				Feasibility Checked, Designed or Reserved state. </p>
        <p>Post-condition(s):The CFSs supporting the product instance are either in the 
				Provisioned_Inactive or Provisioned_Active state. </p>
        <p>In case of success:</p>
        <p>The requesting OS has received an indicated as to whether the test was successful 
				or not. It is important to note that “success” means the test was performed whether or not 
				the CFSs and SAPs are found to be capable of supporting service.</p>
        <p>In case of failure:</p>
        <p>The target OS was not able to perform and test, and an exception is returned to the 
				requesting OS. “Failure” means that the target OS could not perform the test.   </p>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>
      <xsd:sequence>
        <xsd:element name="rootRequest" type="tns:RootRequestType"/>
        <xsd:element name="productName" type="nam:NamingAttributeType"/>
      </xsd:sequence>
    </xsd:complexType>
  </xsd:element>
  <!-- ===================== Test Response Messages ========= -->
  <xsd:element name="testResponse">
    <xsd:annotation>
      <xsd:documentation>
        <p>This type covers the various responses to the retire request.</p>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>
      <xsd:choice maxOccurs="unbounded">
        <xsd:element name="initialResponse" type="sairsp:InitialResponseType"/>
      </xsd:choice>
    </xsd:complexType>
  </xsd:element>
  <!-- ===================== Test Exceptions ========= -->
  <xsd:element name="testException">
    <xsd:annotation>
      <xsd:documentation>
        <p>This type defines the allowable exceptions to the cancel operation.</p>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>
      <xsd:choice>
        <xsd:element name="basicFailureEvent" type="saiexcpt:BasicFailureEventType"/>
      </xsd:choice>
    </xsd:complexType>
  </xsd:element>
  <!-- === Modify === -->
  <!-- ===================== Modify Request Message ========= -->
  <xsd:element name="modifyRequest">
    <xsd:annotation>
      <xsd:documentation>
        <p>This operation takes the CFSs, subscriber, users and SAPs in support of a given (existing) 
				product instance and makes modifications to support the new productInfo, subscribers, users 
				and SAPs listed in the modify request.</p>
        <p>If feasibility check or design have not yet been done for a CFSs supporting the given 
				product instance, this will be done as part of this operation.</p>
        <p>When this request is complete, each CFS (associated with the product instance) shall 
				be in the targetState (either Provisioned_Inactive or Provisioned_Active) with all 
				associated RFSs (and subtending resources) configured and allocated to the appropriate CFS.</p>
        <p>Pre-condition(s): The CFSs supporting the product instance either do not yet exist 
				or are in the FeasibilityChecked, Designed, Reserved (either Reserved-Committed or 
				Reserved-Uncommitted), Provisioned_Inactive, Provisioned_Active state or Terminated.</p>
        <p>Post-condition(s):</p>
        <p>In case of success:</p>
        <p>The CFS(s) associated with the product instance are all in the targetState (either 
				Provisioned_Inactive or Provisioned_Active). Subscribers, users and SAPs will be added or 
				deleted as indicated in the modify request.</p>
        <p>In case of failure:</p>
        <p>In the case of an atomic request, all CFS(s) have all been returned to their original 
				state before the service request. Also, no subscriber, users or SAPs will be added or deleted.</p>
        <p>In the case of best effort, the CFSs associated with the product instance remain in their
                current state. No rollback is attempted in this case.</p>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>
      <xsd:sequence>
        <xsd:element name="basicInput" type="tns:RequestInfoBasicType"/>
        <xsd:element name="soaInput" type="tns:RequestInfoSOAwareType"/>
        <xsd:element name="targetState" type="xsd:string">
          <xsd:annotation>
            <xsd:documentation>
              <p>This is the state to which the target OS wants the CFSs transitioned when the 
						request is complete (the value is either Provisioned_Inactive or Provisioned_Active).</p>
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>
      </xsd:sequence>
    </xsd:complexType>
  </xsd:element>
  <!-- ===================== Modify Response Messages ========= -->
  <xsd:element name="modifyResponse">
    <xsd:annotation>
      <xsd:documentation>
        <p>This type covers the various responses to the modify request.</p>
		<p>Multiple responses to this request are possible, unless there is an exception.
		The expectation is to have on instance of the initialResponse and beginProcessingEvent and
		the possibility of multiple instances of the success and failure responses. There will
		be an indication in the header of the last response which can be either a success or failure
		response.</p>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>
      <xsd:choice maxOccurs="unbounded">
	  	<!-- === Success responses === -->
        <xsd:element name="initialResponse" type="sairsp:InitialResponseType"/>
        <xsd:element name="beginProcessingEvent" type="sairsp:BeginProcessingEventType"/>
        <xsd:element name="cfsCreation" type="sairsp:CfsCreationEventType"/>
        <xsd:element name="cfsDeletion" type="sairsp:CfsDeletionEventType"/>
        <xsd:element name="cfsStateChange" type="sairsp:CfsStateChangeEventType"/>
        <xsd:element name="cfsAvcChange" type="sairsp:CfsAvcEventType"/>
		<!-- === Partial failure responses which are not to be confused with an exception that 
		stops the request === -->
		<xsd:element name="serviceCreationFailureEvent" type="saiexcpt:ServiceCreationFailureEventType"/>
        <xsd:element name="serviceDeletionFailureEvent" type="saiexcpt:ServiceDeletionFailureEventType"/>
        <xsd:element name="serviceStateTransitionFailureEvent" type="saiexcpt:ServiceStateTransitionFailureEventType"/>
        <xsd:element name="serviceAvcFailureEvent" type="saiexcpt:ServiceAvcFailureEventType"/>
      </xsd:choice>
    </xsd:complexType>
  </xsd:element>
  <!-- ===================== Modify Exceptions ========= -->
  <xsd:element name="modifyException">
    <xsd:annotation>
      <xsd:documentation>
        <p>This type defines the allowable exceptions to the modify operation.</p>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>
      <xsd:choice>
        <xsd:element name="basicFailureEvent" type="saiexcpt:BasicFailureEventType"/>
      </xsd:choice>
    </xsd:complexType>
  </xsd:element>
  <!-- === Retrieve Service States === -->
  <!-- ===================== Retrieve Service States Request Message ========= -->
  <xsd:element name="retrieveServiceStatesRequest">
    <xsd:annotation>
      <xsd:documentation>
        <p>This operation returns the name and state for each CFS associated with a given product instance. 
				This would typically be used in lieu of CFS events for creation, state change and deletion. </p>
        <p>Pre-condition(s): The product instance (identified by productName) must already exist.</p>
        <p>Post-condition(s):</p>
        <p>In case of success:</p>
        <p>The CFS(s) associated with the product instance are unchanged.</p>
        <p>The requesting OS has the information that it requested.</p>
        <p>In case of failure:</p>
        <p>The CFS(s) associated with the product instance are unchanged.</p>
        <p>The requesting OS does not have the information that it requested.</p>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>
      <xsd:sequence>
        <xsd:element name="rootRequest" type="tns:RootRequestType"/>
        <xsd:element name="productName" type="nam:NamingAttributeType"/>
      </xsd:sequence>
    </xsd:complexType>
  </xsd:element>
  <!-- ===================== Retrieve Service States Response Messages ========= -->
  <xsd:element name="retrieveServiceStatesResponse">
    <xsd:annotation>
      <xsd:documentation>
        <p>This type covers the response to the retrieve service states request.</p>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>
      <xsd:sequence maxOccurs="unbounded">
        <xsd:element name="cfsName" type="nam:NamingAttributeType"/>
        <xsd:element name="cfsState" type="xsd:string"/>
      </xsd:sequence>
    </xsd:complexType>
  </xsd:element>
  <!-- ===================== Retrieve Service State Exceptions ========= -->
  <xsd:element name="retrieveServiceStatesException">
    <xsd:annotation>
      <xsd:documentation>
        <p>This type defines the allowable exceptions to the retrieveServiceStates operation.</p>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>
      <!-- XML is a bit awkward here. It will not allow just an element within a complexType.
		We could use a sequence with one element or a choice with only one possibility. Decided to
		use choice to align with the format of the other exceptions. -->
      <xsd:choice>
        <xsd:element name="basicFailureEvent" type="saiexcpt:BasicFailureEventType"/>
      </xsd:choice>
    </xsd:complexType>
  </xsd:element>
</xsd:schema>
