<?xml version="1.0" encoding="UTF-8"?>
<!-- mTOP DDP - OM ResourceProvisioning - Copyright TeleManagement Forum 2008 -->
<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:tns="http://www.tmforum.org/mtop/rp/xsd/conc/v1" xmlns:msg="http://www.tmforum.org/mtop/fmw/xsd/msg/v1" xmlns:gen="http://www.tmforum.org/mtop/fmw/xsd/gen/v1" xmlns:nam="http://www.tmforum.org/mtop/fmw/xsd/nam/v1" xmlns:com="http://www.tmforum.org/mtop/nrf/xsd/com/v1" xmlns:lr="http://www.tmforum.org/mtop/nrb/xsd/lay/v1" xmlns:snc="http://www.tmforum.org/mtop/nrf/xsd/snc/v1" xmlns:cc="http://www.tmforum.org/mtop/nrf/xsd/cc/v1" xmlns:test="http://www.tmforum.org/mtop/tm/xsd/test/v1" xmlns:route="http://www.tmforum.org/mtop/nrf/xsd/route/v1" xmlns:routedes="http://www.tmforum.org/mtop/nrf/xsd/routedes/v1" xmlns:tpdata="http://www.tmforum.org/mtop/nrf/xsd/tpdata/v1" xmlns:crcd="http://www.tmforum.org/mtop/nrb/xsd/crcd/v1" xmlns:crmd="http://www.tmforum.org/mtop/nrb/xsd/crmd/v1" targetNamespace="http://www.tmforum.org/mtop/rp/xsd/conc/v1" elementFormDefault="qualified" attributeFormDefault="unqualified" version="1.0">
	<xsd:annotation>
		<xsd:documentation>
			<p>DDP: ResourceProvisioning</p>
			<p>Module:  Message XSD Module</p>
			<p>Description: This module contains the XML Schema type definitions of all the mTOP ConnectionControl SI XML message structures.</p>
		</xsd:documentation>
	</xsd:annotation>
	<!-- ================ -->
	<xsd:import namespace="http://www.tmforum.org/mtop/fmw/xsd/gen/v1" schemaLocation="../../../Framework/IIS/xsd/GeneralDefinitions.xsd"/>
	<xsd:import namespace="http://www.tmforum.org/mtop/fmw/xsd/msg/v1" schemaLocation="../../../Framework/IIS/xsd/MessageDefinitions.xsd"/>
	<xsd:import namespace="http://www.tmforum.org/mtop/fmw/xsd/nam/v1" schemaLocation="../../../Framework/IIS/xsd/NamingDefinitions.xsd"/>
	<xsd:import namespace="http://www.tmforum.org/mtop/nrb/xsd/lay/v1" schemaLocation="../../../NetworkResourceBasic/IIS/xsd/LayerRates.xsd"/>
	<xsd:import namespace="http://www.tmforum.org/mtop/nrf/xsd/com/v1" schemaLocation="../../../NetworkResourceFulfillment/IIS/xsd/CommonTypes.xsd"/>
	<xsd:import namespace="http://www.tmforum.org/mtop/nrf/xsd/snc/v1" schemaLocation="../../../NetworkResourceFulfillment/IIS/xsd/Snc.xsd"/>
	<xsd:import namespace="http://www.tmforum.org/mtop/nrf/xsd/cc/v1" schemaLocation="../../../NetworkResourceFulfillment/IIS/xsd/Cc.xsd"/>
	<xsd:import namespace="http://www.tmforum.org/mtop/nrf/xsd/route/v1" schemaLocation="../../../NetworkResourceFulfillment/IIS/xsd/Route.xsd"/>
	<xsd:import namespace="http://www.tmforum.org/mtop/nrf/xsd/routedes/v1" schemaLocation="../../../NetworkResourceFulfillment/IIS/xsd/RouteDescriptor.xsd"/>
	<xsd:import namespace="http://www.tmforum.org/mtop/nrf/xsd/tpdata/v1" schemaLocation="../../../NetworkResourceFulfillment/IIS/xsd/TpData.xsd"/>
	<xsd:import namespace="http://www.tmforum.org/mtop/nrb/xsd/crcd/v1" schemaLocation="../../../NetworkResourceBasic/IIS/xsd/CommonResourceCreateDataType.xsd"/>
	<xsd:import namespace="http://www.tmforum.org/mtop/nrb/xsd/crmd/v1" schemaLocation="../../../NetworkResourceBasic/IIS/xsd/CommonResourceModifyDataType.xsd"/>
	<xsd:import namespace="http://www.tmforum.org/mtop/tm/xsd/test/v1" schemaLocation="../../../TestManagement/IIS/xsd/Test.xsd"/>
	<!-- ================ -->
	<xsd:element name="activateSubnetworkConnectionRequest">
		<xsd:annotation>
			<xsd:documentation>
				<p>Request message structure of the activateSubnetworkConnection operation</p>
				<p>This operation is used to put an SNC into the ACTIVE state. This operation also applies to bundled SNCs.</p>
				<p>If the SNC represents a Control Plane Connection, the operation is rejected and an exception is raised.</p>
				<p>Success: SNCState in the parameter theSNC is set to SNCS_ACTIVE. All cross-connects required for the SNC were activated successfully. The errorReason parameter is set to an empty string.</p>
				<p>Failure: No exception thrown, except in the cases listed below. If the SNC or any of its network resources have changed as a result of this operation, then no exception can be thrown so that theSNC can be passed back to the Requesting OS. The SNCState in resulting theSNC will be either SNCS_PARTIAL or SNCS_PENDING. The state will be SNCS_PARTIAL if not all cross-connects on MEs have been successfully set up. The state will be SNCS_PENDING if the Target OS mode of operation prevents the activation of the SNC. The errorReason parameter is set accordingly</p>
				<p>For more details on how this service affects the state of an SNC see SD1-23 SNC Management Modes of Operation and SD1-35 SNC state diagram.</p>
				<p>During activation of an SNC, the TPs of the SNC are configured, and the necessary cross-connects are established for the SNC and appropriate changes are made to tpMappingMode such that TPs that are not TP_NA have their tpMappingMode set appropriately for the SNC configuration. See also createSnc() for an explanation of tpMappingMode behaviour. An SNC can be activated while in any state. When activated that additional information provided during the creation is also applied to the SNC in the network.</p>
				<p>In case of an ATM SNC (VP or VC), multiple termination points (VP CTP or VC CTP) can be created as a result of an activateSnc operation. These CTPs are all created/adjusted in compliance with the egress and ingress traffic parameters provided in the tpDataListToModify structure. For example, a non terminated VP SNC created over 3 managed elements will result, upon activation, in the usage of 6 VP CTPs and 3 VP cross-connections.</p>
				<p>Note that the activateSnc operation can be called repeatedly and eventually should succeed (except in conflict cases where the SNC remains in SNCS_PENDING or SNCS_PARTIAL). Should the missing cross-connects be activated in the MEs via a craft interface, for example, prior to communications to those MEs being re-established, the activateSnc command ultimately should succeed when communication to the MEs is re-established (even though all cross-connects already exist).</p>
				<p>The Target OS will apply the transmissionParams specified in the tpDataListToModify parameter (same behaviour as setTerminationPointData operation). They may be applied before or after the creation of the CCs, as appropriate. Existing TP transmission parameters for which no changes were requested in tpDataListToModify will be left unchanged. However, the alarm reporting on the TPs and the containing TPs may be turned on by the Target OS as part of this request, unless otherwise specified via the transmission parameter "AlarmReporting". A similar behaviour is also allowed for the serviceState parameter, which may be set to IN_SERVICE for the TPs and the containing TPs. See SD1-16 transmissionParameters.</p>
				<p>If a given entry in the list of transmission parameters specified in the TPDataType can not be successfully applied to the TP, for any reason, then the errorReason field is appended with an appropriate reason text. Applying transmission parameters is best-effort (where not stated otherwise) and the resulting values of the transmission parameters are provided in the updated tpDataListToModify parameter. If the parameter is "not best effort" then the whole operation will be rejected and the appropriate exception thrown (see exceptions below).</p>
				<p>An already active SNC can be activated again; the Target OS is allowed to not send the commands to the ME a second time for the cross connect establishment however the commands may be sent for the transmission parameters. While in SNCS_PARTIAL state, it is possible to activate an SNC again, this corresponds to a retry.</p>
				<p>Note that all the SNC routes, intended and backup, if any, are unlocked. The restoration process will take control of the unlocked routes and activate the proper one. The behavior of sncState is the same in case there is only one route or more routes of the SNC.</p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element name="sncRef" type="nam:NamingAttributeType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>The name of the subnetwork connection to be activated</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="tolerableImpact" type="com:GradesOfImpactType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>The maximum tolerable impact allowed.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="osFreedomLevel" type="com:FreedomLevelType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>The maximum level of freedom allowed to the Target OS to perform the activation.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="tpDataListToModify" type="tpdata:TerminationPointDataListType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>A list of TPs and parameters to apply.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name="activateSubnetworkConnectionResponse">
		<xsd:annotation>
			<xsd:documentation>
				<p>Response message structure of the activateSubnetworkConnection operation</p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element name="tpDataListToModify" type="tpdata:TerminationPointDataListType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>A list of updated TPs to provide the resulting parameters.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="activatedSnc" type="snc:SubnetworkConnectionType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>The subnetwork connection after the operation.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="errorReason" type="xsd:string" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>Specifies the activation error(s) if any.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name="activateSubnetworkConnectionException">
		<xsd:annotation>
			<xsd:documentation>
				<p>Exception message structure of the activateSubnetworkConnection operation</p>
				<p>notInValidState - Raised where the SNC would involve a CTP that is not connectable due to the state of the server TP or in the case of inverse multiplexing where the SNC would involve a CTP that is not connectable due to the state of the client TP.</p>
				<p>unableToComply - Raised if the SNC is in PENDING state and is in conflict with another ACTIVE or PARTIAL SNC.</p>
				<p>Raised when the target OS is unable to execute the request because at least one of the parameters although valid can not be set and that parameter is identified as "not best effort" in the SD1-16 Layered Transmission Parameters document or in the SD1-1 Additional Information Usage document.</p>
				<p>Raised if the SNC cannot be activated because the target OS cannot comply for a reason different from the ones above.</p>
				<p>Raised if the SNC name references a Connection in the Control Plane. If the target OS cannot determine the reason it could not comply, it is also allowed to throw unableToComply.</p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:complexContent>
				<xsd:restriction base="msg:AllExceptionsType">
					<xsd:choice>
						<xsd:element ref="msg:commLoss"/>
						<xsd:element ref="msg:entityNotFound"/>
						<xsd:element ref="msg:internalError"/>
						<xsd:element ref="msg:invalidInput"/>
						<xsd:element ref="msg:notImplemented"/>
						<xsd:element ref="msg:notInValidState"/>
						<xsd:element ref="msg:objectInUse"/>
						<xsd:element ref="msg:timeslotInUse"/>
						<xsd:element ref="msg:unableToComply"/>
					</xsd:choice>
				</xsd:restriction>
			</xsd:complexContent>
		</xsd:complexType>
	</xsd:element>
	<!-- ================ -->
	<xsd:element name="addRouteRequest">
		<xsd:annotation>
			<xsd:documentation>
				<p>Request message structure of the addRoute operation</p>
				<p>This operation creates a new route (e.g. for restoration purposes) and 
   associates it to the given SNC. The route is created in locked state.</p>
				<p>A route belongs to only one SNC. However CCs/TPs can be shared by 
   routes of different SNCs.</p>
				<p>A route applies to CCs at the same layer of the SNC. The route id must 
   be an unique identifier within the SNC name, with format up to Target OS.</p>
				<p>It is possible to specify if the creating route is the INTENDED route or 
   not; if intended, then the former intended route is updated to backup 
   route. Only one intended route can be associated to a given SNC at a 
   time.</p>
				<p>It is possible to specify if the creating route is EXCLUSIVE or not; if EXCLUSIVE, then the Target OS must find a route that does not conflict or share CCs with any other existing SNC route, in any administrative state.</p>
				<p>Once an EXCLUSIVE route has been created by Target OS, any further creation operation which conflicts with the exclusive route shall be refused.</p>
				<p>A route implicitly inherits from its SNC the following attributes:<ul>
						<li>the endpoints</li>
						<li>owner</li>
						<li>direction</li>
						<li>rerouteAllowed</li>
						<li>networkRouted</li>
						<li>connectionRate</li>
						<li>type</li>
						<li>protectionEffort is considered 
   EFFORT_SAME, i.e. if Target OS can not create a route with same static protection 
   level as the SNC, the operation is refused.</li>
					</ul>
				</p>
				<p>If the SNC represents a Control Plane Connection, an exception is raised.</p>
				<p>Note: The relationship between Bundled SNC service and the SNC with Multiple Routes feature requires further study and is not applicable for v3.0.</p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element name="sncRef" type="nam:NamingAttributeType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>This parameter indicates the name of the already created Subnetwork Connection
            to which the Route shall be added</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="routeCreateData" type="tns:RouteCreateDataType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>This parameter provides the structure describing the new Route
            to be added to the Subnetwork Connection</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="tolerableImpact" type="com:GradesOfImpactType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>The maximum tolerable impact allowed.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="osFreedomLevel" type="com:FreedomLevelType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>The maximum level of freedom allowed to the Target OS to perform the creation.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name="addRouteResponse">
		<xsd:annotation>
			<xsd:documentation>
				<p>Response message structure of the addRoute operation</p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element name="addedRoute" type="routedes:RouteDescriptorType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>This parameter returns the created Route.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="errorReason" type="xsd:string" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>Specifies the activation error(s) if any.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name="addRouteException">
		<xsd:annotation>
			<xsd:documentation>
				<p>Exception message structure of the addRoute operation</p>
				<p>unableToComply - Raised if the sncName references a Connection in the control plane.</p>
				<p>Raised if the target OS can not meet the GradesOfImpact requested.</p>
				<p>Raised when the target OS is unable to execute the request because at least one of the parameters although valid can not be set and that parameter is identified as "not best effort" in the SD1-1 Additional Information Usage document.</p>
				<p>If the target OS cannot determine the reason it could not comply, it is also allowed to throw unableToComply.</p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:complexContent>
				<xsd:restriction base="msg:AllExceptionsType">
					<xsd:choice>
						<xsd:element ref="msg:commLoss"/>
						<xsd:element ref="msg:entityNotFound"/>
						<xsd:element ref="msg:internalError"/>
						<xsd:element ref="msg:invalidInput"/>
						<xsd:element ref="msg:notImplemented"/>
						<xsd:element ref="msg:objectInUse"/>
						<xsd:element ref="msg:protectionEffortNotMet"/>
						<xsd:element ref="msg:unableToComply"/>
						<xsd:element ref="msg:unsupportedRoutingConstraints"/>
					</xsd:choice>
				</xsd:restriction>
			</xsd:complexContent>
		</xsd:complexType>
	</xsd:element>
	<!-- ================ -->
	<xsd:element name="checkValidSubnetworkConnectionRequest">
		<xsd:annotation>
			<xsd:documentation>
				<p>Request message structure of the checkValidSubnetworkConnection operation</p>
				<p>The Requesting OS uses this operation to check if it is possible to create and maybe activate an SNC as specified in the input parameters. This operation also applies to bundled SNCs (see SD1-3 Bundled SNC overview for further details).</p>
				<p>If the context is a MLSN of MLRA type, the operation is rejected and an exception is raised.</p>
				<p>The 
				 should check for the existence of hardware that will support the requested SNC. If the mustConsiderResources parameter is false, the check must be independent of the current specific resource usage in the subnetwork (as in createSnc). If the mustConsiderResources parameter is true, the check must consider the current specific resource usage in the subnetwork (as in activateSnc); in that case, the rules of the Target OS' mode of operation apply to the check (see SD1-23_ModesOfOperation).</p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element name="createData" type="tns:SubnetworkConnectionCreateDataType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>Data about the potential SNC.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="tpDataListToModify" type="tpdata:TerminationPointDataListType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>A list of TPs and parameters that would be applied to the potential SNC.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="mustConsiderResources" type="xsd:boolean" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>Indicates whether or not resource allocation must be considered.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name="checkValidSubnetworkConnectionResponse">
		<xsd:annotation>
			<xsd:documentation>
				<p>Response message structure of the checkValidSubnetworkConnection operation</p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element name="isValid" type="xsd:boolean" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>Indicates if this is a valid SNC.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name="checkValidSubnetworkConnectionException">
		<xsd:annotation>
			<xsd:documentation>
				<p>Exception message structure of the checkValidSubnetworkConnection operation</p>
				<p>unableToComply - Raised if the target OS is unable to find a route for the SNC. Raised if context is a MLSN of MLRA type.</p>
				<p>Raised when the target OS is unable to execute the request because at least one of the parameters although valid could not be set and that parameter is identified as "not best effort" in the SD1-16 Layered Transmission Parameters document or in the SD1-1 Additional Information Usage document.</p>
				<p>Raised if the SNC could not be activated because the requesting OS cannot comply for a reason different from the ones above. If the target OS cannot determine the reason it could not comply, it is also allowed to throw unableToComply.</p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:complexContent>
				<xsd:restriction base="msg:AllExceptionsType">
					<xsd:choice>
						<xsd:element ref="msg:commLoss"/>
						<xsd:element ref="msg:internalError"/>
						<xsd:element ref="msg:invalidInput"/>
						<xsd:element ref="msg:notImplemented"/>
						<xsd:element ref="msg:objectInUse"/>
						<xsd:element ref="msg:unableToComply"/>
						<xsd:element ref="msg:unsupportedRoutingConstraints"/>
						<xsd:element ref="msg:userlabelInUse"/>
					</xsd:choice>
				</xsd:restriction>
			</xsd:complexContent>
		</xsd:complexType>
	</xsd:element>
	<!-- ================ -->
	<xsd:element name="createAndActivateSubnetworkConnectionRequest">
		<xsd:annotation>
			<xsd:documentation>
				<p>Request message structure of the createAndActivateSubnetworkConnection operation</p>
				<p>This operation provides a way to create and activate a subnetwork connection in one command. As with the createSnc() operation and the activateSnc() operation, this operation also applies to bundled SNCs (see SD1-3 Bundled SNC overview for further details).</p>
				<p>If the SNC represents a Control Plane Connection, the operation is rejected and an exception is raised.</p>
				<p>It conceptually behaves like a call to createSnc followed by a call to activateSnc. Therefore, if the pending state is supported, it is possible for the SNC to be created but activation to be rejected, and the resulting SNC will be in pending state. If the pending state is not supported, then this is not possible and the SNC will not be created if activation is rejected. All success/failure conditions that apply to the two base operations also apply to the combined operation.</p>
				<p>If the SNC or any of its network resources have changed as a result of this operation, then no exception can be thrown so that theSNC can be passed back to the Requesting OS. Therefore, the exceptions that apply to activateSnc may not apply to the combined operation: if the creation was successful but the activation is rejected (only possible if the pending state is supported), no exception shall be thrown and the resulting SNC shall be provided in the out parameter createdSnc.</p>
				<p>For more details on how this service affects the state of an SNC see SD1-23 SNC Management Modes of Operation and SD1-35 SNC state diagram.</p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element name="createData" type="tns:SubnetworkConnectionCreateDataType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>Data about the potential SNC.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="tolerableImpact" type="com:GradesOfImpactType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>The maximum tolerable impact allowed.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="osFreedomLevel" type="com:FreedomLevelType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>This parameter indicates the maximum level of freedom allowed to the target OS
            to perform the creation and activation.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="tpDataListToModify" type="tpdata:TerminationPointDataListType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>A list of TPs and parameters to apply.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name="createAndActivateSubnetworkConnectionResponse">
		<xsd:annotation>
			<xsd:documentation>
				<p>Response message structure of the createAndActivateSubnetworkConnection operation</p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element name="tpDataListToModify" type="tpdata:TerminationPointDataListType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>A list of updated TPs to provide the resulting parameters.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="createdSnc" type="snc:SubnetworkConnectionType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>The subnetwork connection after the operation.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="testList" type="test:TestListType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>
							<p>The list of  proactive tests that were successfully created.</p>
						</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="errorReason" type="xsd:string" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>Specifies the activation error(s) if any.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name="createAndActivateSubnetworkConnectionException">
		<xsd:annotation>
			<xsd:documentation>
				<p>Exception message structure of the createAndActivateSubnetworkConnection operation</p>
				<p>notInValidState - Raised where the SNC would involve a CTP that is not connectable due to the state of the server TP or in the case of inverse multiplexing where the SNC would involve a CTP that is not connectable due to the state of the client TP.</p>
				<p>unableToComply - Raised if the SNC represents a Connection in the Control Plane.</p>
				<p>Raised if the target OS is unable to find a route for the SNC. Raised if the target OS can not meet the GradesOfImpact requested.</p>
				<p>Raised when the target OS is unable to execute the request because at least one of the parameters although valid can not be set and that parameter is identified as "not best effort" in the SD1-16 Layered Transmission Parameters document or in the SD1-1 Additional Information Usage document.</p>
				<p>Raised if the SNC cannot be activated because the target OS cannot comply for a reason different from the ones above. If the target OS cannot determine the reason it could not comply, it is also allowed to throw unableToComply.</p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:complexContent>
				<xsd:restriction base="msg:AllExceptionsType">
					<xsd:choice>
						<xsd:element ref="msg:commLoss"/>
						<xsd:element ref="msg:entityNotFound"/>
						<xsd:element ref="msg:internalError"/>
						<xsd:element ref="msg:invalidInput"/>
						<xsd:element ref="msg:notImplemented"/>
						<xsd:element ref="msg:notInValidState"/>
						<xsd:element ref="msg:objectInUse"/>
						<xsd:element ref="msg:protectionEffortNotMet"/>
						<xsd:element ref="msg:unableToComply"/>
						<xsd:element ref="msg:unsupportedRoutingConstraints"/>
						<xsd:element ref="msg:userlabelInUse"/>
					</xsd:choice>
				</xsd:restriction>
			</xsd:complexContent>
		</xsd:complexType>
	</xsd:element>
	<!-- ================ -->
	<xsd:element name="createModifiedSubnetworkConnectionRequest">
		<xsd:annotation>
			<xsd:documentation>
				<p>Request message structure of the createModifiedSubnetworkConnection operation</p>
				<p>The Requesting OS invokes the createModifiedSNC to request the Target OS to modify the addressed SNC route. If the Target OS does not preserve the SNC name, then the method will create a new pending SNC from an existing pending or active SNC. It is similar to createSnc() (which provides details of creation behaviour) but the created SNC is made from data provided by an existing SNC and may replace the existing SNC.</p>
				<p>This operation does not apply to bundled SNCs (see SD1-3 Bundled SNC overview for further details).</p>
				<p>If the SNC Name references a Control Plane connection, the operation is rejected.</p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element name="sncRef" type="nam:NamingAttributeType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>The name of the subnetwork connection to be modified.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="routeId" type="xsd:string" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>The id of the route to be modifed. Empty string, indicates that the "intended" route is to be modified.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="modifyData" type="tns:SubnetworkConnectionModifyDataType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>Structure describing the new/modified subnetwork connection. When the modify type is set to "rerouting", the Target OS should use the routing constraints (if any) to reroute the SNC from end to end. When the modify type is set to "add_protection" (leg) or "remove_protection" (leg), the Target OS should only try to modify the SNC by applying or removing the legs provided in the input parameters. When adding or removing a protection leg, the Target OS should compute the differencing of cross connect on NE.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="tolerableImpact" type="com:GradesOfImpactType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>This parameter qualifies the tolerable conditions under which the SNC modification may be performed.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="tolerableImpactEffort" type="com:ProtectionEffortType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>Qualifies the conditions under which an SNC modification may be performed is a qualification of the requirement that the tolerableImpact as specified, is met.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="osFreedomLevel" type="com:FreedomLevelType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>The maximum level of freedom allowed to the Target OS to perform the activation.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="tpDataListToModify" type="tpdata:TerminationPointDataListType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>A list of TPs and parameters to apply.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name="createModifiedSubnetworkConnectionResponse">
		<xsd:annotation>
			<xsd:documentation>
				<p>Response message structure of the createModifiedSubnetworkConnection operation</p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element name="tpDataListToModify" type="tpdata:TerminationPointDataListType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>A list of updated TPs to provide the resulting parameters.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="newOrModifiedSnc" type="snc:SubnetworkConnectionType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>The modified SNC. It will have sncState and name set. The Target OS selects the SNC names so that they are not reused (within a reasonable time frame) for different SNCs.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="errorReason" type="xsd:string" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>Specifies the activation error(s) if any.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name="createModifiedSubnetworkConnectionException">
		<xsd:annotation>
			<xsd:documentation>
				<p>Exception message structure of the createModifiedSubnetworkConnection operation</p>
				<p>unableToComply - Raised if the SNC cannot be created because it cannot comply with any of the input parameter constraints for a reason different than the ones above.</p>
				<p>Raised if the SNC name represents a connection in the control plane. If the target OS cannot determine the reason it could not comply, it is also allowed to throw unableToComply.</p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:complexContent>
				<xsd:restriction base="msg:AllExceptionsType">
					<xsd:choice>
						<xsd:element ref="msg:commLoss"/>
						<xsd:element ref="msg:entityNotFound"/>
						<xsd:element ref="msg:internalError"/>
						<xsd:element ref="msg:invalidInput"/>
						<xsd:element ref="msg:notImplemented"/>
						<xsd:element ref="msg:objectInUse"/>
						<xsd:element ref="msg:protectionEffortNotMet"/>
						<xsd:element ref="msg:unableToComply"/>
						<xsd:element ref="msg:unsupportedRoutingConstraints"/>
						<xsd:element ref="msg:userlabelInUse"/>
					</xsd:choice>
				</xsd:restriction>
			</xsd:complexContent>
		</xsd:complexType>
	</xsd:element>
	<!-- ================ -->
	<xsd:element name="createSubnetworkConnectionRequest">
		<xsd:annotation>
			<xsd:documentation>
				<p>Request message structure of the createSubnetworkConnection operation</p>
				<p>The Requesting OS invokes the createSnc service to request the Target OS to create an SNC given the parameters passed in the method. This operation also applies to bundled SNCs (see SD1-3 Bundled SNC overview for further details).</p>
				<p>This operation only applies to SNCs which are not in the context of a Control Plane. If the context is a MLSN of MLRA type, the operation is rejected and an exception generated.</p>
				<p>Failure : This will throw an exception if it fails. No SNC object will be created on the Target OS.</p>
				<p>Success : SNC is created in the Target OS and the SNCState is set to the appropriate state in the parameter theSNC. The parameter theSNC will contain the attributes of the created SNC.</p>
				<p>For more details on how this service affects the state of an SNC see SD1-23 SNC Management Modes of Operation and SD1-35 SNC state diagram.</p>
				<p>An SNC may be created between any TPs. At a "CM" end point (a G.805 CP) the span of the SNC starts with a fixed or flexible connection through the ME at the SNC layer, i.e. the connectable layer of the end point. At an "LC"end point the span of the SNC starts with a G.805 TCP with mapping mode set to TM_TERMINATED_AND_AVAILABLE_FOR_MAPPING.</p>
				<p>This operation may be used to create subnetwork connections. There is some variety to the form that SNCs may take. Examples of these SNCs are provided in SD1-18 Layering. The following list shows the essence of variety of SNCs. An SNC may be one:
      <ul>
						<li>in which CTPs are all cross-connected and their tpMappingMode is set to TM_NEITHER_TERMINATED_NOR_AVAILABLE_FOR_MAPPING. In this case G.805 trails could be created by the Requesting OS by using setTerminationPointData to terminate and map CTPs that are adjacent to the CTP at the end of subnetwork connections created by means of createSnc.</li>
						<li>in which one or more end FTP/CTPs expose G.805 TCPs e.g. CTP type F referenced in SD1-18 Layering. If all ends of the SNC terminate on this type of TP then the SNC provides the full route of a G.805 Trail.</li>
						<li>in which one or more end CTP offer the capability to terminate and map and the SNC reaches the end CTP via the PTP/FTP containing the CTP. In this case the SNC creation also sets the tpMappingMode to TM_TERMINATED_AND_AVAILABLE_FOR_MAPPING as well as creating the crossconnects. If all ends of the SNC terminate on this type of TP or any combination of this type of TP and TPs that expose G.805 TCPs (see above) then the SNC provides the full route of a G.805 Trail.</li>
						<li>in which an end TP is a PTP (which is effectively permanently "terminated and available for mapping". If all ends of the SNC terminate on this type of TP or any combination of this type of TP, CTPs offering the capability to terminate and map and TPs that expose G.805 TCPs (see above) then the SNC provides the full route of a G.805 Trail.</li>
					</ul>
				</p>
				<p>CreateSNC allows for the creation of either point-to-point connections or legs of point-to-multipoint connections.</p>
				<p>To add a leg to a broadcast system, the aEnd TP in SNCCreateDataType shall be populated with the common source TP of the broadcast system. Each leg of a broadcast system is a separate SNC and is managed individually, even though they may share cross-connects.</p>
				<p>To create a broadcast system from a Point to Point SNC, the aEnd of the Point to Point SNC is used as the aEnd TP in tpdata:TerminationPointDataListType.</p>
				<p>If an existing SNC respects all the conditions described in createData, then the Target OS is allowed to return that existing SNC. It is also allowed for the Target OS to attempt to create a different SNC as explained below. The rest of the description below applies to the cases where the Target OS decides to create a new SNC.</p>
				<p>If the Requesting OS specifies a routing constraint in the request, then the Target OS must respect the specified constraint even if there are pending, partial, or active SNCs using the required parts of the route.</p>
				<p>The SNC is created with its intended route, in locked state. By means of other operations it is possible to add (then remove) additional routes for restoration purposes. By means of dedicated parameter, it is possible to specify if the intended route is EXCLUSIVE or not; if EXCLUSIVE, then the Target OS must find a route that does not conflict or share CCs or TPs with any other existing SNC route, in any administrative state. Once an EXCLUSIVE (intended) route has been created by Target OS, any further creation operation which conflicts with the exclusive route shall be refused.</p>
				<p>The Target OS tries to find a route for the request and if found returns the snc:SubnetworkConnectionType structure back to the Requesting OS with the members set to the appropriate values. The Target OS should attempt to find a route that does not conflict or share CCs with any other existing SNC, before it resorts to creating a conflicting SNC or an SNC that shares CCs.</p>
				<p>If the TPs at the Aend and the Zend are already in use by another SNC, the Target OS may still create the SNC or EXCPT_OBJECT_IN_USE or EXCPT_TIMESLOT_IN_USE may be thrown, depending on its mode of operation.</p>
				<p>If there already exists between the same termination points and with the same directionality and type, another SNC that is in the partial state, the Target OS will still attempt to create the new SNC. If no constraint is specified, the Target OS should attempt to find a different path. If constraints are specified, then the Target OS attempts to create the SNC with an appropriate route.</p>
				<p>If a route cannot be found, the SNC is not created in the Target OS and the EXCPT_UNABLE_TO_COMPLY exception is thrown (unless a more precise exception applies), indicating the reason.</p>
				<p>Depending on the SNC management mode of operation, it is acceptable for an Target OS to not implement this service in which case the EXCPT_NOT_IMPLEMENTED exception is thrown.</p>
				<p>VC SNCs are normally created over a VP network. Therefore, the VPI numbers of the VC SNCs specified with createData should match existing terminated and mapped VP CTPs. If a VPI number does not match an existing VP CTP, then the Target OS may create the VP CTP as 'TERMINATED and MAPPED' if osFreedomLevel allows it. Such a VP CTP is created with no traffic parameters. Note that such automatic creation of resourceless terminated VP CTPs depends on the capability of the Target OS and/or the ATM NE to support VC connections directly on ATM links (i.e., with no VP overlay network).</p>
				<p>A Requesting OS can request the Target OS to create an ATM network routed SNC (VP or VC layer rates); the Target OS will then manage the subnetwork connection as a soft PVC. The soft PVC may be completely or partially defined with regards to its source and destination TPs. The aEnd will, by definition, be the source of the Soft PVC (i.e., the originator of the call) and the zEnd will be the destination (i.e., being called). In order to allow the Requesting OS to manage Soft PVCs that may have only their source TPs in the subnetwork, the ctpName parameter from TPDataList zEnd will be used to either specify the VPI and/or VCI value of the destination CTP (including Target OS, managedElement, PTP/FTP and ATM_NI a.k.a., the full location in the physical ATM NE)or the address of the ATM interface on which the call will terminate and optionally the VPI/VCI values if they are specified/known by the Requesting OS (but not the complete physical location of the VP or VC TP).</p>
				<p>Note that all SNC state transitions (including to/from PENDING and PARTIAL) are applicable to ATM VPCs and VCCs. However, the PARTIAL state should only apply to plain PVCs (intermediate CTPs of a Soft PVC are automatically created and deleted by the network elements and they do not usually notify the Target OS).</p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element name="createData" type="tns:SubnetworkConnectionCreateDataType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>Data about the potential SNC.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="tolerableImpact" type="com:GradesOfImpactType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>The maximum tolerable impact allowed.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="osFreedomLevel" type="com:FreedomLevelType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>The maximum level of freedom allowed to the Target OS to perform the activation.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name="createSubnetworkConnectionResponse">
		<xsd:annotation>
			<xsd:documentation>
				<p>Response message structure of the createSubnetworkConnection operation</p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element name="createdSnc" type="snc:SubnetworkConnectionType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>The newly created SNC. It will have sncState and name set. The Target OS selects the SNC names so that they are not reused (within a reasonable time frame) for different SNCs.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="errorReason" type="xsd:string" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>Specifies the activation error(s) if any.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name="createSubnetworkConnectionException">
		<xsd:annotation>
			<xsd:documentation>
				<p>Exception message structure of the createSubnetworkConnection operation</p>
				<p>Raised if the target OS is unable to find an appropriate route for the SNC or the context is a MLSN of MLRA type.</p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:complexContent>
				<xsd:restriction base="msg:AllExceptionsType">
					<xsd:choice>
						<xsd:element ref="msg:commLoss"/>
						<xsd:element ref="msg:entityNotFound"/>
						<xsd:element ref="msg:internalError"/>
						<xsd:element ref="msg:invalidInput"/>
						<xsd:element ref="msg:notImplemented"/>
						<xsd:element ref="msg:objectInUse"/>
						<xsd:element ref="msg:protectionEffortNotMet"/>
						<xsd:element ref="msg:unableToComply"/>
						<xsd:element ref="msg:unsupportedRoutingConstraints"/>
						<xsd:element ref="msg:userlabelInUse"/>
					</xsd:choice>
				</xsd:restriction>
			</xsd:complexContent>
		</xsd:complexType>
	</xsd:element>
	<!-- ================ -->
	<xsd:element name="deactivateAndDeleteSubnetworkConnectionRequest">
		<xsd:annotation>
			<xsd:documentation>
				<p>Request message structure of the deactivateAndDeleteSubnetworkConnection operation</p>
				<p>This operation provides a way to deactivate and then delete a subnetwork connection in one operation. As with the deactivateSnc(), operation and the deleteSnc() operation, this operation also applies to bundled SNCs (see SD1-3 Bundled SNC overview for further details).</p>
				<p>If the SNC represents a Control Plane Connection, the operation is rejected and an exception is raised.</p>
				<p>It conceptually behaves like a call to deactivateSnc followed by a call to deleteSnc. All success/failure conditions that apply to the two base operations also apply to the combined operation. If the SNC or any of its network resources have changed as a result of this operation, then no exception can be thrown so that deletedSnc can be passed back to the Requesting OS. Therefore, the exceptions that apply to deleteSnc may not apply to the combined operation: if the deactivation changed the SNC but the deletion is rejected,no exception should be thrown and the resulting SNC should be provided in the out parameter theSNC.</p>
				<p>The parameter deletedSnc will identify the SNC after the combined operation. If the operation is entirely successful, state will be SNCS_NONEXISTENT. In that case, this object does not exist on the Target OS and the Requesting OS should only look at state. This work around is so that the Requesting OS can have a combined operation.</p>
				<p>For more details on how this operation affects the state of an SNC see SD1-23 SNC Management Modes of Operation and SD1-35 SNC state diagram.</p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element name="sncRef" type="nam:NamingAttributeType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>The name of the subnetwork connection to be deactivated and deleted.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="tolerableImpact" type="com:GradesOfImpactType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>Indicates the amount of traffic disruption that the Requesting OS user is willing to tolerate as a result of the deactivation and deletion request.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="osFreedomLevel" type="com:FreedomLevelType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>The maximum level of freedom allowed to the Target OS to perform the deactivation and deletion.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="tpDataListToModify" type="tpdata:TerminationPointDataListType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>A list of TPs and parameters to apply.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name="deactivateAndDeleteSubnetworkConnectionResponse">
		<xsd:annotation>
			<xsd:documentation>
				<p>Response message structure of the deactivateAndDeleteSubnetworkConnection operation</p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element name="tpDataListToModify" type="tpdata:TerminationPointDataListType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>A list of updated TPs to provide the resulting parameters.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="theSnc" type="snc:SubnetworkConnectionType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>This parameter returns the complete information of the deleted SubnetworkConnection object
            (that it had before it was deleted)</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="errorReason" type="xsd:string" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>Specifies the deactivation and/or deletion error(s) if any.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name="deactivateAndDeleteSubnetworkConnectionException">
		<xsd:annotation>
			<xsd:documentation>
				<p>Exception message structure of the deactivateAndDeleteSubnetworkConnection operation</p>
				<p>unableToComply - Raised if the SNC is fixed and can not be deactivated or it represents a connection on the Control Plane.</p>
				<p>Raised when the target OS is unable to execute the request because at least one of the parameters although valid can not be set and that parameter is identified as "not best effort" in the SD1-16 Layered Transmission Parameters document (such that the TPs will be left in an invalid state after the deactivate operation).</p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:complexContent>
				<xsd:restriction base="msg:AllExceptionsType">
					<xsd:choice>
						<xsd:element ref="msg:commLoss"/>
						<xsd:element ref="msg:entityNotFound"/>
						<xsd:element ref="msg:internalError"/>
						<xsd:element ref="msg:invalidInput"/>
						<xsd:element ref="msg:notImplemented"/>
						<xsd:element ref="msg:unableToComply"/>
					</xsd:choice>
				</xsd:restriction>
			</xsd:complexContent>
		</xsd:complexType>
	</xsd:element>
	<!-- ================ -->
	<xsd:element name="deactivateSubnetworkConnectionRequest">
		<xsd:annotation>
			<xsd:documentation>
				<p>Request message structure of the deactivateSubnetworkConnection operation</p>
				<p>Deactivating an SNC implies deletion in the ME of all the non-shared cross-connects that belong to this SNC and makes appropriate changes to tpMappingMode such that TPs that are not TP_NA have their tpMappingMode set to TM_NEITHER_TERMINATED_NOR_AVAILABLE_FOR_MAPPING as a result of this operation. See also createSnc(), for an explanation of tpMappingMode behaviour. The ports are left in the same state and are not put out of service.</p>
				<p>This operation applies to SNCs and bundled SNCs (see SD1-3 Bundled SNC overview for further details).</p>
				<p>If the SNC represents a Control Plane Connection, the operation is rejected and an exception raised.</p>
				<p>Failure - No exception thrown (except for cases described below). If the SNC or any of its network resources have changed as a result of this operation, then no exception can be thrown so that theSNC can be passed back to the Requesting OS. The SNCState will be either SNCS_PARTIAL if the command partially completed or SNCS_ACTIVE if no cross-connects were deleted. The errorReason will be detailed accordingly.</p>
				<p>Success - SNC is deactivated in the Target OS and the SNCState is set to SNCS_PENDING in the out parameter theSNC. The parameter deactivatedSNC will contain the attributes of the deactivated SNC. The errorReason parameter may be set to an empty string.</p>
				<p>For more details on how this service affects the state of an SNC see SD1-23 SNC Management Modes of Operation and SD1-35 SNC state diagram.</p>
				<p>The Target OS will apply the transmissionParams specified in the tpDataListToModify parameter (same behaviour as setTerminationPointData operation). They may be applied before or after the creation of the CCs, as appropriate. See SD1-16 transmissionParameters.</p>
				<p>If a given entry in the list of transmission parameters specified in tpDataListToModify can not be successfully applied to the TP, for any reason, then the errorReason field is appended with an appropriate reason text. Applying transmission parameters is best-effort (where not stated otherwise) and the resulting values of the transmission parameters are provided in the updated tpDataListToModify parameter. If the parameter is "not best effort" then the whole operation will be rejected and the appropriate exception thrown (see exceptions below).</p>
				<p>Existing TP transmission parameters for which no changes were requested in transmissionParams will be left unchanged. However, the alarm reporting on the TPs and the containing TPs may be turned off by the Target OS as part of this request, unless otherwise specified via the parameter "isAlarmReporting".</p>
				<p>An already deactivated SNC can be deactivated again with success (the Target OS is allowed to not send the commands to the ME a second time however). While in SNCS_PARTIAL state, it is possible to deactivate an SNC again, this corresponds to a retry.</p>
				<p>If the SNC has more alternative routes, then the operation locks all the SNC routes, intended and backup.</p>
				<p>In case of a VP or VC SNC, this operation implies deletion in the ME of all the non-shared VP or VC CTPs and VP or VC cross-connections involved in the SNC. Note that in the case of a VC SNC deactivation, only the VC CTP and VC cross-connections are normally deleted. VP CTPs must be explicitly deleted using deactivateSnc on the VP SNC, except when osFreedomLevel allows it. In that case, the VP CTP can be deleted along with the VC SNC if the VP CTP no longer contains any VC CTPs.</p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element name="sncRef" type="nam:NamingAttributeType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>The name of the subnetwork connection to be deactivated.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="tolerableImpact" type="com:GradesOfImpactType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>The maximum tolerable impact allowed. Indicates the amount of traffic disruption that the Requesting OS user is willing to tolerate as a result of the deactivation request.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="osFreedomLevel" type="com:FreedomLevelType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>The maximum level of freedom allowed to the Target OS to perform the deactivation.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="tpDataListToModify" type="tpdata:TerminationPointDataListType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>A list of TPs and parameters to apply</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name="deactivateSubnetworkConnectionResponse">
		<xsd:annotation>
			<xsd:documentation>
				<p>Response message structure of the deactivateSubnetworkConnection operation</p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element name="tpDataListToModify" type="tpdata:TerminationPointDataListType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>A list of updated TPs to provide the resulting parameters.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="deactivatedSnc" type="snc:SubnetworkConnectionType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>the deactivated subnetwork connection</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="errorReason" type="xsd:string" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>Specifies the deactivation error(s) if any.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name="deactivateSubnetworkConnectionException">
		<xsd:annotation>
			<xsd:documentation>
				<p>Exception message structure of the deactivateSubnetworkConnection operation</p>
				<p>unableToComply - Raised if the SNC is fixed and can not be deactivated or the SNCName references a Connection in the Control Plane.</p>
				<p>Raised when the target OS is unable to execute the request because at least one of the parameters although valid can not be set and that parameter is identified as "not best effort" in the SD1-16 Layered Transmission Parameters document (such that the TPs will be left in an invalid state after the deactivate operation</p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:complexContent>
				<xsd:restriction base="msg:AllExceptionsType">
					<xsd:choice>
						<xsd:element ref="msg:commLoss"/>
						<xsd:element ref="msg:entityNotFound"/>
						<xsd:element ref="msg:internalError"/>
						<xsd:element ref="msg:invalidInput"/>
						<xsd:element ref="msg:notImplemented"/>
						<xsd:element ref="msg:unableToComply"/>
					</xsd:choice>
				</xsd:restriction>
			</xsd:complexContent>
		</xsd:complexType>
	</xsd:element>
	<!-- ================ -->
	<xsd:element name="deleteSubnetworkConnectionRequest">
		<xsd:annotation>
			<xsd:documentation>
				<p>Request message structure of the deleteSubnetworkConnection operation</p>
				<p>This operation also applies to bundled SNCs (see SD1-3 Bundled SNC overview for further details).</p>
				<p>If the SNC represents a Control Plane Connection, the operation is rejected and an exception is raised.</p>
				<p>To delete a leg from a broadcast system, the subnetworkConnection that represents the leg is used as input to the delete SNC operation.</p>
				<p>The SNC must not be in the active or partial state.</p>
				<p>If the SNC has more alternative routes, then the operation deletes the SNC, its intended and all bkp route(s).</p>
				<p>Failure - An exception will be thrown if the operation fails.  The SNC object will not be deleted on the target OS. The errorReason field of the exception will contain the reason for the failure.</p>
				<p>Success - The SNC object is deleted on the target OS.</p>
				<p>For more details on how this service affects the state of an SNC see SD1-23 SNC Management Modes of Operation and SD1-35_StateDiagrams.</p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element name="sncRef" type="nam:NamingAttributeType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>The name of the subnetwork connection to be deleted.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="osFreedomLevel" type="com:FreedomLevelType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>The maximum level of freedom allowed to the Target OS to perform the deletion.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name="deleteSubnetworkConnectionResponse">
		<xsd:annotation>
			<xsd:documentation>
				<p>Response message structure of the deleteSubnetworkConnection operation</p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element name="errorReason" type="xsd:string" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>This parameter returns the error(s) if any.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name="deleteSubnetworkConnectionException">
		<xsd:annotation>
			<xsd:documentation>
				<p>Exception message structure of the deleteSubnetworkConnection operation</p>
				<p>unableToComply - Raised if the SNC represents a Connection in the Control Plane.</p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:complexContent>
				<xsd:restriction base="msg:AllExceptionsType">
					<xsd:choice>
						<xsd:element ref="msg:commLoss"/>
						<xsd:element ref="msg:entityNotFound"/>
						<xsd:element ref="msg:internalError"/>
						<xsd:element ref="msg:invalidInput"/>
						<xsd:element ref="msg:notImplemented"/>
						<xsd:element ref="msg:notInValidState"/>
						<xsd:element ref="msg:unableToComply"/>
					</xsd:choice>
				</xsd:restriction>
			</xsd:complexContent>
		</xsd:complexType>
	</xsd:element>
	<!-- ================ -->
	<xsd:element name="modifySubnetworkConnectionRequest">
		<xsd:annotation>
			<xsd:documentation>
				<p>Request message structure of the modifySubnetworkConnection operation</p>
				<p>The Requesting OS invokes the modifySnc to perform the combined function of createModifiedSnc() and swapSnc() in sequence. The signature of the operation is the same as that of createModifiedSNC().</p>
				<p>This method will modify and activate the SNC on the network. If the Target OS does not preserve the SNC name, then output SNC will have a different name than formerly addressed SNC, which is deactivated and deleted.</p>
				<p>If the SNC name references a Control Plane Connection, the operation is rejected and an exception raised.</p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element name="sncRef" type="nam:NamingAttributeType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>The name of the subnetwork connection to be modified.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="routeId" type="xsd:string" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>The id of the route to be modifed. Empty string, indicates that the "intended" route is to be modified.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="modifyData" type="tns:SubnetworkConnectionModifyDataType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>Structure describing the new/modified subnetwork connection.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="tolerableImpact" type="com:GradesOfImpactType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>The maximum tolerable impact allowed.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="tolerableImpactEffort" type="com:ProtectionEffortType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>This parameter qualifies the tolerable conditions under which the SNC modification may be performed.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="osFreedomLevel" type="com:FreedomLevelType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>The maximum level of freedom allowed to the Target OS to perform the modification.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="tpDataListToModify" type="tpdata:TerminationPointDataListType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>A list of TPs and parameters to apply</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name="modifySubnetworkConnectionResponse">
		<xsd:annotation>
			<xsd:documentation>
				<p>Response message structure of the modifySubnetworkConnection operation</p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element name="tpDataListToModify" type="tpdata:TerminationPointDataListType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>A list of updated TPs to provide the resulting parameters.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="newOrModifiedSnc" type="snc:SubnetworkConnectionType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>The modified SNC. It will have sncState and name set. The Target OS selects the SNC names so that they are not reused (within a reasonable time frame) for different SNCs.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="errorReason" type="xsd:string" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>Specifies the modification error(s) if any.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name="modifySubnetworkConnectionException">
		<xsd:annotation>
			<xsd:documentation>
				<p>Exception message structure of the modifySubnetworkConnection operation</p>
				<p>notInValidState - Raised where the SNC would involve a CTP that is not connectable due to the state of the server TP or in the case of inverse multiplexing where the SNC would involve a CTP that is not connectable due to the state of the client TP.</p>
				<p>unableToComply - Raised in the SNC name references a Connection in the control plane.</p>
				<p>Raised if the target OS is unable to find a route for the SNC. Raised if the target OS can not meet the GradesOfImpact requested.</p>
				<p>Raised when the target OS is unable to execute the request because at least one of the parameters although valid can not be set and that parameter is identified as "not best effort" in the SD1-16 Layered Transmission Parameters document or in the SD1-1 Additional Information Usage document.</p>
				<p>Raised if the SNC cannot be activated because the target OS cannot comply for a reason different from the ones above. If the target OS cannot determine the reason it could not comply, it is also allowed to throw unableToComply.</p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:complexContent>
				<xsd:restriction base="msg:AllExceptionsType">
					<xsd:choice>
						<xsd:element ref="msg:commLoss"/>
						<xsd:element ref="msg:entityNotFound"/>
						<xsd:element ref="msg:internalError"/>
						<xsd:element ref="msg:invalidInput"/>
						<xsd:element ref="msg:notImplemented"/>
						<xsd:element ref="msg:notInValidState"/>
						<xsd:element ref="msg:objectInUse"/>
						<xsd:element ref="msg:protectionEffortNotMet"/>
						<xsd:element ref="msg:unableToComply"/>
						<xsd:element ref="msg:unsupportedRoutingConstraints"/>
						<xsd:element ref="msg:userlabelInUse"/>
					</xsd:choice>
				</xsd:restriction>
			</xsd:complexContent>
		</xsd:complexType>
	</xsd:element>
	<!-- ================ -->
	<xsd:element name="removeRouteRequest">
		<xsd:annotation>
			<xsd:documentation>
				<p>Request message structure of the removeRoute operation</p>
				<p>This operation allows an Requesting OS to request the deletion of a route of given 
   SubnetworkConnection on a specified subnetwork.</p>
				<p>The addressed route must not be in the unlocked  state, and must not be 
   the intended route.</p>
				<p>Of course it is possible to delete a locked backup route which is "in 
   use" by other SNC route, because this operation has no side effect on 
   routes of any other SNCs, even if sharing CCs/TPs.</p>
				<p>Failure - An exception will be thrown if the operation fails. The route will not be deleted on the target OS.
   The errorReason field of the exception will contain the reason for the failure.</p>
				<p>Success - The route is deleted on the target OS.</p>
				<p>If the SNC represents a Control Plane Connection, an exception is raised.</p>
				<p>Note: The relationship between Bundled SNC service and the SNC with Multiple Routes feature
        requires further study.</p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element name="sncRef" type="nam:NamingAttributeType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>The name of the subnetwork connection</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="routeId" type="xsd:string" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>The id of the route.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="osFreedomLevel" type="com:FreedomLevelType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>The maximum level of freedom allowed to the Target OS to perform the deletion.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="vendorExtensions" type="gen:AnyListType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>
							<p>This is a container for all operation request message vendor extensions.</p>
						</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name="removeRouteResponse">
		<xsd:annotation>
			<xsd:documentation>
				<p>Response message structure of the removeRoute operation</p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element name="vendorExtensions" type="gen:AnyListType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>
							<p>This is a container for all operation response message vendor extensions.</p>
						</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name="removeRouteException">
		<xsd:annotation>
			<xsd:documentation>
				<p>Exception message structure of the removeRoute operation</p>
				<p>notInValidState - Raised if the route is in the unlocked state, or if the route is the intended one.</p>
				<p>unableToComply - Raised if the sncName references a Connection in the control plane.</p>
				<p>Raised when the target OS is unable to execute the request because at least one of the parameters although valid can not be set and that parameter is identified as "not best effort" in the SD1-1 Additional Information Usage document.</p>
				<p>If the target OS cannot determine the reason it could not comply, it is also allowed to throw unableToComply.</p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:complexContent>
				<xsd:restriction base="msg:AllExceptionsType">
					<xsd:choice>
						<xsd:element ref="msg:commLoss"/>
						<xsd:element ref="msg:entityNotFound"/>
						<xsd:element ref="msg:internalError"/>
						<xsd:element ref="msg:invalidInput"/>
						<xsd:element ref="msg:notImplemented"/>
						<xsd:element ref="msg:notInValidState"/>
						<xsd:element ref="msg:unableToComply"/>
					</xsd:choice>
				</xsd:restriction>
			</xsd:complexContent>
		</xsd:complexType>
	</xsd:element>
	<!-- ================ -->
	<xsd:element name="setIntendedRouteRequest">
		<xsd:annotation>
			<xsd:documentation>
				<p>Request message structure of the setIntendedRoute operation</p>
				<p>This operation allows an Requesting OS to request to set the addressed route as 
   intended route. The formerly intended route (if different from addressed) 
   is no longer the intended one, in order to respect the rule that an SNC 
   must have one intended route, and only one. The addressed route can be in 
   any administrative / actual state.</p>
				<p>If the SNC represents a Control Plane Connection, an exception is raised.</p>.
        <p>Note: The relationship between Bundled SNC service and the SNC with Multiple Routes feature
        requires further study and is not applicable for v3.0.</p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element name="sncRef" type="nam:NamingAttributeType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>The name of the subnetwork connection.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="routeId" type="xsd:string" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>The id of the route.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="vendorExtensions" type="gen:AnyListType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>
							<p>This is a container for all operation request message vendor extensions.</p>
						</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name="setIntendedRouteResponse">
		<xsd:annotation>
			<xsd:documentation>
				<p>Response message structure of the setIntendedRoute operation</p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element name="vendorExtensions" type="gen:AnyListType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>
							<p>This is a container for all operation response message vendor extensions.</p>
						</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name="setIntendedRouteException">
		<xsd:annotation>
			<xsd:documentation>
				<p>Exception message structure of the setIntendedRoute operation</p>
				<p>unableToComply -  Raised if the sncName references a Connection in the control plane.</p>
				<p>Raised when the target OS is unable to execute the request because at least one of the parameters although valid can not be set and that parameter is identified as "not best effort" in the SD1-1 Additional Information Usage document.</p>
				<p>If the target OS cannot determine the reason it could not comply, it is also allowed to throw unableToComply.</p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:complexContent>
				<xsd:restriction base="msg:AllExceptionsType">
					<xsd:choice>
						<xsd:element ref="msg:commLoss"/>
						<xsd:element ref="msg:entityNotFound"/>
						<xsd:element ref="msg:internalError"/>
						<xsd:element ref="msg:invalidInput"/>
						<xsd:element ref="msg:notImplemented"/>
						<xsd:element ref="msg:unableToComply"/>
					</xsd:choice>
				</xsd:restriction>
			</xsd:complexContent>
		</xsd:complexType>
	</xsd:element>
	<!-- ================ -->
	<xsd:element name="setRoutesAdminStateRequest">
		<xsd:annotation>
			<xsd:documentation>
				<p>Request message structure of the setRoutesAdminState operation</p>
				<p>This operation allows an Requesting OS to specify a list of routes jointly with their 
   provisioned administrative state. If all routes of a given SNC are 
   successfully locked, then the SNC state transits to pending. If the SNC 
   state was partial or pending, and at least one route is successfully 
   unlocked, then the SNC state may transits to active.</p>
				<p>If the SNC represents a Control Plane Connection, an exception is raised.</p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element name="sncRef" type="nam:NamingAttributeType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>The name of the subnetwork connection.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="routeNameAndAdminStateList" type="tns:RouteNameAndAdminStateListType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>the list of route IDs plus their administrative state.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name="setRoutesAdminStateResponse">
		<xsd:annotation>
			<xsd:documentation>
				<p>Response message structure of the setRoutesAdminState operation</p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element name="routeNameAndAdminStateList" type="tns:RouteNameAndAdminStateListType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>The list of route IDs plus their administrative state.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="sncState" type="com:SubnetworkConnectionStateType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>The subnetwork connection state after the operation.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name="setRoutesAdminStateException">
		<xsd:annotation>
			<xsd:documentation>
				<p>Exception message structure of the setRoutesAdminState operation</p>
				<p>unableToComply - Raised if the sncName references a Connection in the control plane.</p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:complexContent>
				<xsd:restriction base="msg:AllExceptionsType">
					<xsd:choice>
						<xsd:element ref="msg:commLoss"/>
						<xsd:element ref="msg:entityNotFound"/>
						<xsd:element ref="msg:internalError"/>
						<xsd:element ref="msg:invalidInput"/>
						<xsd:element ref="msg:notImplemented"/>
						<xsd:element ref="msg:unableToComply"/>
					</xsd:choice>
				</xsd:restriction>
			</xsd:complexContent>
		</xsd:complexType>
	</xsd:element>
	<!-- ================ -->
	<xsd:element name="swapSubnetworkConnectionRequest">
		<xsd:annotation>
			<xsd:documentation>
				<p>Request message structure of the swapSubnetworkConnection operation</p>
				<p>The swapSNC operation will deactivate an identified active SNC (state changes to pending) and activate an identified pending SNC. The pending SNC may have been created by using a createSnc() or a createModifiedSnc().</p>
				<p>If any of the SNCs represent a Control Plane Connection, an exception is raised.</p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element name="sncToBeDeactivatedRef" type="nam:NamingAttributeType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>The name of the subnetwork connection to be deactivated.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="sncToBeActivatedRef" type="nam:NamingAttributeType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>The name of the subnetwork connection to be activated.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="tolerableImpact" type="com:GradesOfImpactType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>The maximum tolerable impact allowed.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="osFreedomLevel" type="com:FreedomLevelType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>The maximum level of freedom allowed to the Target OS to perform the activation.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="tpDataListToModify" type="tpdata:TerminationPointDataListType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>A list of TPs and parameters to apply</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name="swapSubnetworkConnectionResponse">
		<xsd:annotation>
			<xsd:documentation>
				<p>Response message structure of the swapSubnetworkConnection operation</p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element name="tpDataListToModify" type="tpdata:TerminationPointDataListType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>A list of updated TPs to provide the resulting parameters.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="stateOfActivatedSnc" type="com:SubnetworkConnectionStateType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>The state of the activated subnetwork connection after the operation.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="errorReason" type="xsd:string" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>Specifies the error(s) if any.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name="swapSubnetworkConnectionException">
		<xsd:annotation>
			<xsd:documentation>
				<p>Exception message structure of the swapSubnetworkConnection operation</p>
				<p>notInValidState - Raised where the SNC would involve a CTP that is not connectable due to the state of the server TP or in the case of inverse multiplexing where the SNC would involve a CTP that is not connectable due to the state of the client TP.</p>
				<p>unableToComply - Raised if any of the SNCs represent a Connection in the Control Plane.</p>
				<p>Raised if the target OS is unable to find a route for the SNC. Raised if the target OS can not meet the GradesOfImpact requested.</p>
				<p>Raised when the target OS is unable to execute the request because at least one of the parameters although valid can not be set and that parameter is identified as "not best effort" in the SD1-16 Layered Transmission Parameters document or in the SD1-1 Additional Information Usage document.</p>
				<p>Raised if the SNC cannot be activated because the target OS cannot comply for a reason different from the ones above. If the target OS cannot determine the reason it could not comply, it is also allowed to throw unableToComply.</p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:complexContent>
				<xsd:restriction base="msg:AllExceptionsType">
					<xsd:choice>
						<xsd:element ref="msg:commLoss"/>
						<xsd:element ref="msg:entityNotFound"/>
						<xsd:element ref="msg:internalError"/>
						<xsd:element ref="msg:invalidInput"/>
						<xsd:element ref="msg:notImplemented"/>
						<xsd:element ref="msg:notInValidState"/>
						<xsd:element ref="msg:objectInUse"/>
						<xsd:element ref="msg:unableToComply"/>
					</xsd:choice>
				</xsd:restriction>
			</xsd:complexContent>
		</xsd:complexType>
	</xsd:element>
	<!-- ================ -->
	<xsd:element name="switchRouteRequest">
		<xsd:annotation>
			<xsd:documentation>
				<p>Request message structure of the switchRoute operation</p>
				<p>This operation is used to activate the input route and deactivate the 
   current (or partial) route(s), if different from input route. The operation 
   is rejected if performed on a pending SNC. The operation does not affect 
   the administrativeState of any route. The restoration process may re-route 
   again, e.g. in case of failures.</p>
				<p>If the SNC represents a Control Plane Connection, an exception is raised.</p>
				<p>
					<b>Success</b>: output parameter sncState is set to SNCS_ACTIVE. All 
   cross-connects required for the given route were activated successfully, 
   and if needed, all the cross-connects of former current (or partial) 
   route(s) were deactivated successfully. The errorReason parameter is set to 
   an empty string.</p>
				<p>
					<b>Failure</b>: No exception thrown, except in the cases listed below. 
   If the SNC or any of its network resources have changed as a result of this 
   operation, then no exception can be thrown so that the sncState can be 
   passed back to the Requesting OS. The resulting SNCState will be either SNCS_PARTIAL 
   or SNCS_ACTIVE.</p>
				<p>The sncState will be SNCS_PARTIAL if not all cross-connects (of given 
   input route) on MEs have been successfully set up, and there is not an 
   active route. Moreover one or more of the cross-connects to be removed may 
   be still active, this leads to two (or more) routes in partial state.</p>
				<p>The sncState will be SNCS_ACTIVE if all cross-connects (of given input 
   route) on MEs have been successfully set up, but one or more of the cross-
   connects (of any of the other partial routes) to be removed are still 
   active, this leads to one route in active state and another (or more) route 
   in partial state. The errorReason parameter is set accordingly.</p>
				<p>Recovery scenarios: this operation can be performed again addressing<ul>
						<li>an already active route, in order to retry the deactivation of other 
   route(s) in partial state.</li>
						<li> a partial route, in order to retry its activation (and retry, if 
   needed, the deactivation of other partial routes as well).</li>
					</ul>
				</p>
				<p>The Target OS will apply the transmissionParams specified in the tpDataListToModify 
   parameter (same behaviour as setTerminationPointData operation). They may be applied before or 
   after the creation of the CCs, as appropriate. Existing TP transmission 
   parameters for which no changes were requested in tpDataListToModify will be left 
   unchanged. However, the alarm reporting on the connected TPs and the 
   containing TPs may be turned on by the Target OS as part of this request, unless 
   otherwise specified via the transmission parameter "AlarmReporting". A 
   similar behaviour is also allowed for the serviceState parameter, which may 
   be set to IN_SERVICE for the TPs. See SD1-16_LayeredParameters.pdf </p>
				<p>If a given entry in the list of transmission parameters specified in the 
   TpData can not be successfully applied to the TP, for any reason, then 
   the errorReason field is appended with an appropriate reason text. Applying 
   transmission parameters is best-effort (where not stated 
   otherwise) and the resulting values of the 
   transmission parameters are provided in the updated tpDataListToModify 
   parameter.</p>
				<p>An already active SNC route can be activated again; the Target OS is allowed 
   to not send the commands to the ME a second time for the cross connect 
   establishment however the commands may be sent for the transmission 
   parameters.</p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element name="sncRef" type="nam:NamingAttributeType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>The name of the subnetwork connection.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="routeId" type="xsd:string" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>The id of the route.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="tolerableImpact" type="com:GradesOfImpactType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>The maximum tolerable impact allowed.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="osFreedomLevel" type="com:FreedomLevelType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>The maximum level of freedom allowed to the Target OS to perform the deletion.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="tpDataListToModify" type="tpdata:TerminationPointDataListType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>A list of TPs and parameters to apply.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="vendorExtensions" type="gen:AnyListType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>
							<p>This is a container for all operation request message vendor extensions .</p>
						</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name="switchRouteResponse">
		<xsd:annotation>
			<xsd:documentation>
				<p>Response message structure of the switchRoute operation</p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element name="tpDataListToModify" type="tpdata:TerminationPointDataListType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>A list of TPs and parameters to apply.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="vendorExtensions" type="gen:AnyListType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>
							<p>This is a container for all operation request message vendor extensions .</p>
						</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="sncState" type="com:SubnetworkConnectionStateType" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>The subnetwork connection state after the operation.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
				<xsd:element name="errorReason" type="xsd:string" minOccurs="0">
					<xsd:annotation>
						<xsd:documentation>Specifies the error(s) if any.</xsd:documentation>
					</xsd:annotation>
				</xsd:element>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name="switchRouteException">
		<xsd:annotation>
			<xsd:documentation>
				<p>Exception message structure of the switchRoute operation</p>
				<p>notInValidState - Raised where the SNC would involve a CTP that is not connectable due to the state of the server TP or in the case of inverse multiplexing where the SNC would involve a CTP that is not connectable due to the state of the client TP.</p>
				<p>unableToComply - Raised if the SNC Name references a Connection in the control plane.</p>
				<p>Raised if the target OS can not meet the GradesOfImpact requested.</p>
				<p>Raised when the target OS is unable to execute the request because at least one of the parameters although valid can not be set and that parameter is identified as "not best effort" in the SD1-16 Layered Transmission Parameters document or in the SD1-1 Additional Information Usage document.</p>
				<p>Raised if the route cannot be activated because the target OS cannot comply for a reason different from the ones above. If the target OS cannot determine the reason it could not comply, it is also allowed to throw unableToComply.</p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:complexContent>
				<xsd:restriction base="msg:AllExceptionsType">
					<xsd:choice>
						<xsd:element ref="msg:commLoss"/>
						<xsd:element ref="msg:entityNotFound"/>
						<xsd:element ref="msg:internalError"/>
						<xsd:element ref="msg:invalidInput"/>
						<xsd:element ref="msg:notImplemented"/>
						<xsd:element ref="msg:notInValidState"/>
						<xsd:element ref="msg:objectInUse"/>
						<xsd:element ref="msg:unableToComply"/>
					</xsd:choice>
				</xsd:restriction>
			</xsd:complexContent>
		</xsd:complexType>
	</xsd:element>
	<!-- ================ -->
	<xsd:complexType name="SubnetworkConnectionCreateDataType">
		<xsd:annotation>
			<xsd:documentation>
				<p>The attributes required for the creation of a subnetworkConnection or a Control Plane Connection on the Target OS are packaged together in this data structure which the Requesting OS will pass to the Target OS at SNC/Connection creation time.</p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="crcd:CommonResourceCreateDataType">
				<xsd:sequence>
					<xsd:element name="direction" type="com:ConnectionDirectionType" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>The connection directionality must be specified by the Requesting OS.</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="staticProtectionLevel" type="com:StaticProtectionLevelType" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>The Requesting OS must specify the requested staticProtectionLevel as specified in SD1-36 SNC Types.</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="protectionEffort" type="com:ProtectionEffortType" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>The Requesting OS must specify the protectionEffort as specified in SD1-36 SNC Types.</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="rerouteAllowed" type="com:RerouteType" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>
								<p>This attribute indicates if the Target OS/MEs are allowed and/or required to reroute this SNC if there is a failure on this SNC, periodically to optimize the routes, or for any other reason.</p>
								<p>It is an Target OS/ME implementation whether this is done using network routing protocols or if the Target OS/MEs detect the failure and take appropriate action to attempt to fix the SNC.</p>
								<p>There is no requirement for the reroutes to respect the constraints specified in the creation request (ccInclusions, Resource Inclusions and Exclusions).</p>
							</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="networkRouted" type="com:NetworkRoutedType" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>This attribute specifies if the network is allowed/required to route this SNC.</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="type" type="com:SubnetworkConnectionTypeType" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>The Requesting OS must specify the sncType as specified in SD1-36 SNC Types.</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="layerRate" type="lr:LayerRateType" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>Identifies the layer at which the SNC is to be made.</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="ccInclusionList" type="cc:CrossConnectListType" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>
								<p>Specifies a list of cross-connects that must be used by the SNC or Control Plane Connection, in which case are Routing Node connections, ended by SNPs or SNPPs, and the optional TNA/FTP/CTP end point values are provided by a/zEndTpList, a/zEndTnaNameOrGroupTnaName parameters.</p>
								<p>The list must be empty if no cross-connect constraints are required.</p>
							</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="inclusionResourceRefList" type="nam:NamingAttributeListType" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>
								<p>Specifies a list of MLRAs/MEs/TLs/MLSNPPLinks/MLSNPP/TPs/GTPs that must be used by the SNC. The list must be empty if no MLRAs/MEs/TLs/MLSNPPLinks/MLSNPP/TPs/GTPs constraints are required.</p>
								<p>If the target OS cannot fully satisfy the constraints, then the request will be rejected.</p>
								<p>Specifying both inclusion and exclusion constraints is not supported, therefore this list must be empty if exclusionResourceRefList is not empty.</p>
							</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="isFullRoute" type="xsd:boolean" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>
								<p>This attribute indicates whether the provided inclusion constraints specifies the complete route of the SNC or routing leg (as opposed to only a partial constraint). When no inclusions constraints are specified, false must be used.</p>
							</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="exclusionResourceRefList" type="nam:NamingAttributeListType" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>
								<p>Specifies a list of MLRAs/MEs/TLs/MLSNPPLinks/MLSNPP/TPs/GTPs/SNCs to be excluded. The SNC or Control Plane Connection to be created must not use any of the MLRAs/MEs/TLs/MLSNPPLinks/MLSNPP/TPs/GTPs/SNCs specified, nor any resource used by the SNCs or Connection specified.</p>
								<p>List must be empty if no exclusion constraints are required.</p>
								<p>Specifying both inclusion and exclusion constraints is not supported, therefore this list must be empty if ccInclusionList or inclusionResourceRefList is non empty.</p>
							</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="aEndTpRefList" type="nam:NamingAttributeListType" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>
								<p>The requesting OS must specify the aEnd of the subnetworkConnection. This attribute provides the name of the CTP/FTP/GTP in a non-control plane SNC.</p>
								<p>Is also used to indicate the Source TP when adding a leg to an existing broadcast system. If the TP is an FTP the Requesting OS is allowed to specify a generic end point within a ME, the Target OS will choose the appropriate TP instance. See SD1-25 Object Naming for further detail.</p>
								<p>If the SNC participates in a VCAT connection, this attribute may be null. The interface will simply pass the concatenation level, leaving to target OS the freedom to choose proper virtually concatenated SNC end points.</p>
								<p>If the SNC represents a Control Plane Connection the aEnd may be identified in this attribute or in aEndTnaNameOrGroupTnaName, aEndTpListadditional attributes depending upon the information available to the target OS (as understood by the requesting OS).</p>
								<p>The value of this attribute may identify an MLSNPP or an MLSNPPLink (if available) or may be left empty. The SNPP/SNP identifier may be appended to the MLSNPP/MLSNPPLink name or may be provided in place of the MLSNPP/MLSNPPLink name to name a remote point.</p>
								<p>For a detailed description of the use of this attribute, see SD1-36 SNC Types.</p>
							</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="zEndTpRefList" type="nam:NamingAttributeListType" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>Same behavior as aEnd attribute applies. Is also used to indicate the Sink TP when adding a leg to an existing broadcast system. If the Requesting OS supplies an invalid combination of TPs in aEnd and zEnd, then the Target OS will throw an INVALID_INPUT exception. Aend and Zend TPs have to be on the same subnetwork.</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="aEndTpRoleList" type="com:EndPointRoleListType" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>
          Defines the element that defines the end point role of all aEnd TPs of an SNC. This is an ordered list indexed with the aEndTpRefList of the SNC.
          </xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="isReportingAlarms" type="xsd:boolean" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>
Provides an indication whether alarm reporting for this instance is active or not.
          </xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="networkReroute" type="xsd:string" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>
								<p>Indicates if the reroute of an SNC (if allowed) should be computed by the network, by the Target OS, or if it does not matter. Values are "Yes", "No", "NotSet".</p>
							</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="isRevertive" type="xsd:boolean" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>
								<p>Takes value "True" when an SNC can be switched back to its original route.</p>
							</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="isRevertiveReroute" type="xsd:boolean" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>
								<p>Indicates whether the rerouting of an SNC is revertive or not.</p>
							</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="intendedRouteAEnds" type="xsd:string" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>
								<p>Must be specified when creating an SNC with multiple routes in case the end points of the intended route are a subset of SNC end points. Value is "aEnd-i-j-k-..." where i, j, k are the indexes of SNC aEnd points.</p>
							</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="isIntendedRouteExclusive" type="xsd:boolean" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>
								<p>Specifies when creating an SNC with multiple routes if the intended route is EXCLUSIVE or not; if EXCLUSIVE, then the Target OS must find a route that does not conflict or shared CCs or CTPs with any other existing SNC route, in any state (pending/partial/current). Once an EXCLUSIVE (intended) route has been created by the Target OS, any further creation operation which conflicts with the exclusive route shall be rejected.</p>
							</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="intendedRouteZEnds" type="xsd:string" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>
								<p>Must be specified when creating an SNC with multiple routes in case the end points of the intended route are a subset of SNC end points. Value is "zEnd-i-j-k-..." where i, j, k are the indexes of SNC zEnd points.</p>
							</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="priority" type="xsd:unsignedInt" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>
								<p>The SNC creation priority, where 0 is the highest priority.</p>
								<p>The priority allows to prevent activating routes because of CC or CTP conflicts with equal or higher prior SNCs.</p>
								<p>An SNC or a Connection in the Control Plane can pre-empt resources of another SNC of lower priority for restoration purposes.</p>
							</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="zEndTpRoleList" type="com:EndPointRoleListType" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>
								<p>Defines the element that defines the end point role of all zEnd TPs of an SNC. This is an ordered list indexed with the zEndTpRefList of the SNC.</p>
							</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="asapRef" type="nam:NamingAttributeType" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>
								<p>Indicates the assignment of an ASAP to this SNC object. Value is the ASAP name.</p>
							</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="blsrDirection" type="xsd:string" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>
								<p>Used in conjunction with Timeslot when the Target OS cannot use the routing constraints for a BLSR case.</p>
							</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="isBundledSnc" type="xsd:boolean" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>
								<p>Indicates whether the SNC constitutes a Bundled SNC service (value True) or not.</p>
							</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="mustRemoveGtps" type="xsd:boolean" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>
								<p>This attribute defines that the target OS has to delete all the interior Group Termination Points (GTPs) supporting the bundled Subnetwork Connection (SNC) when the SNC is deleted. The attribute is only used when creating bundled SNCs.</p>
								<p>It can take on two possible values:<uL>
										<li>true (the target OS must make a best-effort attempt to remove the interior GTPs that once belonged to the SNC) and</li>
										<li>false (the requesting OS doesn't care if the target OS removes the interior GTPs or not).</li>
									</uL>
								</p>
								<p>In the case that mustRemoveGtps is set to "true" and the target OS cannot remove all the interior GTPs, the target OS should return a list of the GTPs that could not be removed in the errorReason field of the deactivateAndDeleteSnc and deleteSnc operations. The errorReason will be "not all interior GTPs could be deleted" - this will be followed by the names of the GTPs that could not be deleted.</p>
							</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="potentialFutureSetupIndicator" type="com:PotentialFutureSetupIndicatorType" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>
								<p>Refers to data type.</p>
							</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="routingConstraintEffort" type="xsd:string" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>
								<p>The effort required for routing constraint application.</p>
								<p>Legal Values are:<ul>
										<li>BEST_EFFORT</li>
										<li>EXACT_MATCH</li>
									</ul>
								</p>
							</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="timeslot" type="xsd:integer" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>
								<p>Used in conjunction with blsrDirection.</p>
							</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<!-- @@ added from Additional Info March 2011 ================ -->
					<xsd:element name="aEndTnaNameOrGroupTnaName" type="xsd:string" nillable="true" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>
								<p>Represent the TNA or Group-TNA of the Connection. A TNA Name List may have 3 value pairs.</p>
								<p>Format: \name=TNAName\value=TNANameValue\name=LogicalPortId\value=LogicalPortIdValue\name= Index\value=IndexValue.</p>
							</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="zEndTnaNameOrGroupTnaName" type="xsd:string" nillable="true" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>
								<p>see aEndTNANameOrGroupTNAName.</p>
							</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="aEndTpList" type="xsd:string" nillable="true" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>
								<p>String representing a sequence of name-value pairs. The backslash (\) character is used as separator.</p>
								<p>Format: \name=OS\value=CompanyName/OSname\name=ME\value=ManagedElementName\name=PTP\value=PTPName\name=CTP\value=CTPName E.g.: \name=OS\value=BigCompany/SmallEMS\name=ME\value=YellowManagedElement\name=PTP\value=BluePTP\name=CTP\value=RedCTP</p>
							</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="zEndTpList" type="xsd:string" nillable="true" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>
								<p>see aEndTpList.</p>
							</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="maximumCost" type="xsd:string" nillable="true" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>
								<p>The maximum link/node cost allowed for routing.</p>
							</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="routeGroupLabel" type="xsd:string" nillable="true" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>
								<p>This attribute shall represent the route group of the connection.</p>
							</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="connectionName" type="xsd:string" nillable="true" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>
								<p> String containing the RDN of the Call Name. The value in the last name-value pair of name structure.</p>
								<p> This attribute allows the requesting OS to provision the name of top level Connection at Call establishment.</p>
							</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<!-- @@ end of added from Additional Info March 2011 ================ -->
					<xsd:element name="setDataTestList" type="test:SetTestDataListType" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>This parameter provides a structure of tests to be executed</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<!-- ==================== -->
	<xsd:complexType name="SubnetworkConnectionModifyDataType">
		<xsd:annotation>
			<xsd:documentation>
				<p>The attributes required for the modification of a subnetworkConnection on the Target OS are packaged together in this data structure which the Requesting OS will pass to the Target OS in a request to modify an existing SNC.</p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="crmd:CommonResourceModifyDataType">
				<xsd:sequence>
					<xsd:element name="direction" type="com:ConnectionDirectionType" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>The connection directionality must be specified by the Requesting OS.</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="modifyType" type="com:ModifyType" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>This attribute specifies the class of modification; i.e. rerouting or add/remove protection.</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="mustRetainOldSnc" type="xsd:boolean" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>Request for the Target OS to keep the old SNC in pending state.</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="isModifyServersAllowed" type="xsd:boolean" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>Allow to modify the server layers to fulfil the protection constraint.</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="staticProtectionLevel" type="com:StaticProtectionLevelType" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>The Requesting OS must specify the requested staticProtectionLevel as specified in SD1-36 SNC Types.</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="protectionEffort" type="com:ProtectionEffortType" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>The Requesting OS must specify the protectionEffort as specified in SD1-36 SNC Types.</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="rerouteAllowed" type="com:RerouteType" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>
								<p>This attribute indicates if the Target OS/MEs are allowed and/or required to reroute this SNC if there is a failure on this SNC, periodically to optimize the routes, or for any other reason.</p>
								<p>It is an Target OS/ME implementation whether this is done using network routing protocols or if the Target OS/MEs detect the failure and take appropriate action to attempt to fix the SNC.</p>
								<p>There is no requirement for the reroutes to respect the constraints specified in the creation request (ccInclusions, Resource Inclusions and Exclusions).</p>
							</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="networkRouted" type="com:NetworkRoutedType" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>This attribute specifies if the network is allowed/required to route this SNC.</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="type" type="com:SubnetworkConnectionTypeType" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>The Requesting OS must specify the sncType as specified in SD1-36 SNC Types.</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="layerRate" type="lr:LayerRateType" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>Identifies the layer at which the SNC is to be made.</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="addedOrNewRoute" type="route:RouteListType" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>Depending on the modifyType, AddedOrNewRoute describes the route of a new protection leg or the whole SNC. When it describes a segment to be added, either the SNCP cross-connects or the switch TPs that will be changed in the segment may be specified by the Requesting OS. The Target OS then chooses the missing segments. Alternatively, the Requesting OS may specify the full route.</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="removedRoute" type="route:RouteListType" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>RemovedRoute describes dropping of a protection leg from the original SNC. Either the last cross-connects (that contain the SNCP) are specified by the Requesting OS or the full route may be specified. This parameter can be used in conjunction with addedOrNewRoute only to reroute a segment.</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="inclusionResourceRefList" type="nam:NamingAttributeListType" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>
								<p>Specifies a list of MEs, GTPs, TLs, PTPs, FTPs and/or CTPs that must be used by the SNC. The list must be empty if no constraints are required.</p>
								<p>Specifying both inclusion and exclusion constraints is not supported, therefore this list must be empty if exclusionResourceRefList is not empty.</p>
							</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="isFullRoute" type="xsd:boolean" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>Specifies whether the provided inclusion constraints specifies the complete route of the SNC or routing leg (as opposed to only a partial constraint). When no inclusions constraints are specified, false must be used.</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="exclusionResourceRefList" type="nam:NamingAttributeListType" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>
								<p>Specifies a list of MEs, TLs, PTPs, FTPs, CTPs, and/or SNCs to be excluded.</p>
								<p>This is applicable for adding the leg or doing a full reroute and the route must not use any of the NEs, TLs, PTPs, FTPs and CTPs specified, nor any resource used by the SNCs specified.</p>
								<p>Specifying both inclusion and exclusion constraints is not supported, therefore this list must be empty if inclusionResourceRefList or ccInclusionList are not empty.</p>
							</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="aEndTpRefList" type="nam:NamingAttributeListType" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>The Requesting OS must specify the aEnd (CTP/FTP) as specified in SD1-36 SNC Types. Is also used to indicate the Source TP when adding a leg to an existing broadcast system. If the TP is an FTP the Requesting OS is allowed to specify a generic end point within a ME, the Target OS will choose the appropriate TP instance. See SD1-25 Object Naming for further detail.</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="zEndTpRefList" type="nam:NamingAttributeListType" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>The Requesting OS must specify the zEnd (CTP/FTP) as specified in SD1-36 SNC Types. Is also used to indicate the Sink TP when adding a leg to an existing broadcast system. If the Requesting OS supplies an invalid combination of TPs in aEnd and zEnd, then the Target OS will throw an INVALID_INPUT exception. Aend and Zend TPs have to be on the same subnetwork. If the TP is an FTP the Requesting OS is allowed to specify a generic end point within a ME, the Target OS will choose the appropriate TP instance. See SD1-25 Object Naming for further detail.</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="aEndTpRoleList" type="com:EndPointRoleListType" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>
								<p>Defines the element that defines the end point role of all aEnd TPs of an SNC. This is an ordered list indexed with the aEndTpRefList of the SNC.</p>
							</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="zEndTpRoleList" type="com:EndPointRoleListType" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>
								<p>Defines the element that defines the end point role of all zEnd TPs of an SNC. This is an ordered list indexed with the zEndTpRefList of the SNC.</p>
							</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="isReportingAlarms" type="xsd:boolean" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>
Provides an indication whether alarm reporting for this instance is active or not.
          </xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="networkReroute" type="com:RerouteType" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>
          Indicates if the reroute of an SNC (if allowed) should be computed by the network, by the Target OS, or if it does not matter.
          </xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="isRevertive" type="xsd:boolean" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>Takes value "True" when an SNC can be switched back to its original route.
          </xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="isRevertiveReroute" type="xsd:boolean" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>
          Indicates whether the rerouting of an SNC is revertive or not.
          </xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="asapRef" type="nam:NamingAttributeType" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>
								<p>Indicates the assignment of an ASAP to this SNC object. Value is the ASAP name.</p>
							</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="mustRemoveGtps" type="xsd:boolean" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>
								<p>This attribute defines that the target OS has to delete all the interior Group Termination Points (GTPs) supporting the bundled Subnetwork Connection (SNC) when the SNC is deleted. The attribute is only used for bundled SNCs.</p>
								<p>It can take on two possible values:<uL>
										<li>true (the target OS must make a best-effort attempt to remove the interior GTPs that once belonged to the SNC) and</li>
										<li>false (the requesting OS doesn't care if the target OS removes the interior GTPs or not).</li>
									</uL>
								</p>
								<p>In the case that mustRemoveGtps is set to "true" and the target OS cannot remove all the interior GTPs, the target OS should return a list of the GTPs that could not be removed in the errorReason field of the deactivateAndDeleteSnc and deleteSnc operations. The errorReason will be "not all interior GTPs could be deleted" - this will be followed by the names of the GTPs that could not be deleted.</p>
							</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="priority" type="xsd:unsignedInt" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>
								<p>The SNC creation priority, where 0 is the highest priority.</p>
								<p>The priority allows to prevent activating routes because of CC or CTP conflicts with equal or higher prior SNCs.</p>
								<p>An SNC or a Connection in the Control Plane can pre-empt resources of another SNC of lower priority for restoration purposes.</p>
							</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<!-- ================ -->
	<xsd:complexType name="RouteCreateDataType">
		<xsd:annotation>
			<xsd:documentation>
      Structure is used by the Requesting OS to pass to the Target OS when a route is added to a SNC.
      </xsd:documentation>
		</xsd:annotation>
		<xsd:sequence>
			<xsd:element name="isIntendedRoute" type="xsd:boolean" minOccurs="0">
				<xsd:annotation>
					<xsd:documentation>
						<p>This attribute defines the purpose of the Route to be created. Refer to description in the RouteDescriptor object class.</p>
					</xsd:documentation>
				</xsd:annotation>
			</xsd:element>
			<xsd:element name="isExclusiveRoute" type="xsd:boolean" minOccurs="0">
				<xsd:annotation>
					<xsd:documentation>
						<p>This attribute defines that not any other Routes of other Subnetwork Connections can share any of the Routes Cross Connections or Connection Termination Points, even in pending state (true).</p>
					</xsd:documentation>
				</xsd:annotation>
			</xsd:element>
			<xsd:element name="ccInclusionList" type="cc:CrossConnectListType" minOccurs="0">
				<xsd:annotation>
					<xsd:documentation>Specifies a list of cross-connects that must be used by the route. The 
   list must be empty if no cross-connect constraints are required.</xsd:documentation>
				</xsd:annotation>
			</xsd:element>
			<xsd:element name="inclusionResourceRefList" type="nam:NamingAttributeListType" minOccurs="0">
				<xsd:annotation>
					<xsd:documentation>
						<p>Specifies a list of MLRAs/MEs/TLs/MLSNPPLinks/MLSNPP/TPs/GTPs that must be used by the route. The list must be empty if no MLRAs/MEs/TLs/MLSNPPLinks/MLSNPP/TPs/GTPs constraints are required.</p>
						<p>Specifying both inclusion and exclusion constraints is not supported, therefore this list must be empty if exclusionResourceRefList is not empty.</p>
					</xsd:documentation>
				</xsd:annotation>
			</xsd:element>
			<xsd:element name="isFullRoute" type="xsd:boolean" minOccurs="0">
				<xsd:annotation>
					<xsd:documentation>
						<p>Specifies whether the provided inclusion constraints specifies the complete route details (as opposed to only a partial constraint). When no inclusions constraints are specified, false must be used.</p>
					</xsd:documentation>
				</xsd:annotation>
			</xsd:element>
			<xsd:element name="exclusionResourceRefList" type="nam:NamingAttributeListType" minOccurs="0">
				<xsd:annotation>
					<xsd:documentation>
						<p>Specifies a list of MLRAs/MEs/TLs/MLSNPPLinks/MLSNPP/TPs/GTPs and/or "SNC + routes" to be excluded. The route to be created must not use any of the MLRAs/MEs/TLs/MLSNPPLinks/MLSNPP/TPs/GTPs specified, nor any resource used by the "SNC + routes" specified.</p>
						<p>List must be empty if no exclusion constraints are required.</p>
						<p>Specifying both inclusion and exclusion constraints is not supported, therefore this list must be empty if ccInclusionList or inclusionResourceRefList is non empty.</p>
						<p>"SNC + route" is described by the SNC name followed by the string ("/routeId=") and the route id. If only the SNC name is specified, then its intended route is considered.</p>
					</xsd:documentation>
				</xsd:annotation>
			</xsd:element>
			<xsd:element name="vendorExtensions" type="gen:AnyListType" minOccurs="0">
				<xsd:annotation>
					<xsd:documentation>
						<p>This is a container for all vendor extensions.</p>
					</xsd:documentation>
				</xsd:annotation>
			</xsd:element>
		</xsd:sequence>
	</xsd:complexType>
	<!-- ================= -->
	<xsd:simpleType name="ControlStateType">
		<xsd:annotation>
			<xsd:documentation>
				<p>This state refers to the belonging SNC, and has not any relationship 
   with the actual state. It can assume only the following values:</p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="xsd:string">
			<xsd:enumeration value="LOCKED">
				<xsd:annotation>
					<xsd:documentation>
						<p>the route is not allowed to be active.</p>
					</xsd:documentation>
				</xsd:annotation>
			</xsd:enumeration>
			<xsd:enumeration value="UNLOCKED">
				<xsd:annotation>
					<xsd:documentation>
						<p>the route is allowed to be active.</p>
					</xsd:documentation>
				</xsd:annotation>
			</xsd:enumeration>
		</xsd:restriction>
	</xsd:simpleType>
	<!-- ================= -->
	<xsd:complexType name="RouteNameAndAdminStateType">
		<xsd:annotation>
			<xsd:documentation>
				<p>This structure is used by the Requesting OS to lock or unlock the route of an SNC.</p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:sequence>
			<xsd:element name="id" type="xsd:string" minOccurs="0">
				<xsd:annotation>
					<xsd:documentation>
						<p>Unique identifier within the SNC name, with format up to Target OS.</p>
					</xsd:documentation>
				</xsd:annotation>
			</xsd:element>
			<xsd:element name="administrativeState" type="tns:ControlStateType" minOccurs="0">
				<xsd:annotation>
					<xsd:documentation>
						<p>Refer to the data type definition.</p>
					</xsd:documentation>
				</xsd:annotation>
			</xsd:element>
			<xsd:element name="vendorExtensions" type="gen:AnyListType" minOccurs="0">
				<xsd:annotation>
					<xsd:documentation>
						<p>This is a container for all vendor extensions.</p>
					</xsd:documentation>
				</xsd:annotation>
			</xsd:element>
		</xsd:sequence>
	</xsd:complexType>
	<!-- ================= -->
	<xsd:complexType name="RouteNameAndAdminStateListType">
		<xsd:annotation>
			<xsd:documentation>
				<p>The list of RouteNameAndAdminState structures.</p>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:sequence>
			<xsd:element name="item" type="tns:RouteNameAndAdminStateType" minOccurs="0" maxOccurs="unbounded"/>
		</xsd:sequence>
	</xsd:complexType>
</xsd:schema>
