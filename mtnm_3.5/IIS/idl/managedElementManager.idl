#ifndef managedElementManager_idl
#define managedElementManager_idl

// ********************************
// *                              *
// * managedElementManager.idl    *
// *                              *
// ********************************

//Include list
#include "globaldefs.idl"
#include "common.idl"
#include "managedElement.idl"
#include "transmissionParameters.idl"
#include "terminationPoint.idl"
#include "notifications.idl"
#include "subnetworkConnection.idl"
#include "aSAP.idl"

#pragma prefix "mtnm.tmforum.org"

  /** 
   * <a href=../../../supportingDocumentation/SD1-27_Overview_NML-EML_Interface.pdf >SD1-27 Overview of 
   * NML-EML interface</a>
   *
   * <p>This module contains the definition of the managed element manager
   * of the NML-EML interface.</p>
   *
   * <h5> Version 3.5. </h5>
   **/


module managedElementManager
{
 

  /**
   * <p>The managedElementManager is used to gain access to operations
   * which deal with managed elements and termination points.</p>
   *
   * <p>A handle to an instance of this interface is gained via the
   * emsSessionFactory::EmsSession_I::getManager() operation in Manager.</p>
   **/

 interface ManagedElementMgr_I : common::Common_I
 {

  /**
   * <p>This allows an NMS to request details of all of the Managed Elements 
   * that are under the control of this ManagedElementMgr_I.</p>
   * 
   * <p>In order to allow the NMS to deal with a large number of objects,
   * this operation uses an iterator. See
   * <a href=../../../supportingDocumentation/SD1-15_iterators.pdf >SD1-15 iterator overview</a>
   * for information on how iterators are used in this interface.</p>
   * 
   * <br>unsigned long how_many: Maximum number of MEs to report in the first 
   * batch.
   * <br> managedElement::ManagedElementList_T meList: First batch of MEs.
   * <br>managedElement::ManagedElementIterator_I meIt: Iterator to retrieve 
   * the remaining MEs.
   * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
   *  failure<br>
   * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators 
   *  that the EMS can support has been reached.<br>
   * <br>
   **/
   void getAllManagedElements(
         in unsigned long how_many,
         out managedElement::ManagedElementList_T meList,
         out managedElement::ManagedElementIterator_I meIt) 
        raises(globaldefs::ProcessingFailureException);


  /**
   * <p>This operation has exactly the same behaviour as 
   * getAllManagedElements(), but
   * instead of returning the entire object structures, this operation returns 
   * their names.</p>
   * 
   * <p>In order to allow the NMS to deal with a large number of objects,
   * this operation uses an iterator. See
   * <a href=../../../supportingDocumentation/SD1-15_iterators.pdf >SD1-15 iterator overview</a>
   * for information on how iterators are used in this interface.</p>
   * 
   * <br>unsigned long how_many: Maximum number of ME names to return in the 
   * first batch.
   * <br>globaldefs::NamingAttributesList_T nameList: First batch of ME 
   * names.
   * <br>globaldefs::NamingAttributesListIterator_I nameIt: Iterator to 
   * retrieve remaining ME names.
   * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
   * As for getAllManagedElements()
   **/
   void getAllManagedElementNames(
         in unsigned long how_many,
         out globaldefs::NamingAttributesList_T nameList,
         out globaldefs::NamingAttributesIterator_I nameIt)
        raises(globaldefs::ProcessingFailureException);

  /** 
   * <p>This service returns the list of subnetwork names that the  
   * Managed Element supplied as an input parameter belongs to.<p>
   * <br>globaldefs::NamingAttributes managedElementName: The name of the 
   * managed element for which to retrieve the containing subnetwork names. 
   * <br>globaldefs::NamingAttributesList_T subnetNames: The names of the 
   * subnetworks this NE belongs to.
   * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
   *  failure<br>
   * EXCPT_INVALID_INPUT - Raised when managedElementName does not reference a 
   *  managed element object<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when managedElementName references an ME 
   *  object that does not exist<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
   *  lost<br>
   * <br>
   **/
   void getContainingSubnetworkNames(
         in globaldefs::NamingAttributes_T managedElementName,
         out globaldefs::NamingAttributesList_T subnetNames)
        raises (globaldefs::ProcessingFailureException);

  /**
   * <p>Note: This interface has been enhanced in version 3 to return both PTPs 
   * and FTPs (maximising inter-version compatibility). Two new operations have 
   * been added to getAllPTPsWithoutFTPs() and getAllFTPs() to allow more 
   * selective retrieval. </p>
   *
   * <p>This allows an NMS to request all of the PTPs and FTPs on the specified  
   * Managed Element, that contain one or more of the NMS-specified PTP/FTP 
   * layer rates, and that are capable of supporting one or more of the NMS-
   * specified connection layer rates.
   * If there are no PTPs/FTPs that match the layer constraints, an empty 
   * list is returned. A PTP/FTP will be returned regardless
   * of connectivity to other managed elements and regardless of position
   * in the subnetwork (both edgepoints of the subnetwork and the PTPs/FTPs
   * that are internal to the subnetwork are reported).</p>
   * 
   * <p>In order to allow the NMS to deal with a large number of objects,
   * this operation uses an iterator. See
   * <a href=../../../supportingDocumentation/SD1-15_iterators.pdf >SD1-15 iterator overview</a>
   * for information on how iterators are used in this interface.</p>
   * 
   * <br>globaldefs::NamingAttributes_T managedElementName: The name of the 
   * Managed Element for which to retrieve PTPs/FTPs.
   * <br>transmissionParameters::LayerRateList_T tpLayerRateList: List of 
   * PTP/FTP layer rates for which the PTPs/FTPs are to be fetched. A PTP/FTP 
   * must contain at least one of the layer rates specified to be reported.  If 
   * the list is empty then all PTPs/FTPs (of all rates)are returned.
   * <br>transmissionParameters::LayerRateList_T connectionLayerRateList: List 
   * of connection layer rates for which the PTPs/FTPs are to be fetched. A 
   * PTP/FTP must support connections for at least one of the
   * layer rates specified to be reported.  If the list is empty then all 
   * PTPs/FTPs (for all connection rates) are returned.
   * <br>unsigned long how_many: Maximum number of PTPs/FTPs to report in the 
   * first batch.
   * <br>terminationPoint::TerminationPointList_T tpList: First batch of 
   * PTPs/FTPs.
   * <br>terminationPoint::TerminationPointIterator_I tpIt: Iterator to 
   * retrieve remaining PTPs/FTPs.
   * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
   *  failure<br>
   * EXCPT_INVALID_INPUT - Raised when managedElementName does not reference a 
   *  managed element object, or tpLayerRateList or connectionLayerRateList 
   *  contain undefined rates<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when managedElementName references an ME 
   *  object that does not exist<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
   *  lost<br>
   * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators 
   *  that the EMS can support has been reached<br>
   * <br>
   **/
   void getAllPTPs(
         in globaldefs::NamingAttributes_T managedElementName,
         in transmissionParameters::LayerRateList_T tpLayerRateList,
         in transmissionParameters::LayerRateList_T connectionLayerRateList,
         in unsigned long how_many,
         out terminationPoint::TerminationPointList_T tpList,
         out terminationPoint::TerminationPointIterator_I tpIt) 
        raises(globaldefs::ProcessingFailureException);


  /**
   * <p>Note: This interface has been added in version 3 to return PTPs 
   * only. It allows more selective retrieval than the modified 
   * getAllPTPs() which now returns PTPs and FTPs. </p>
   * <p>This operation has exactly the same behaviour as 
   * getAllPTPs() but
   * instead of returning both PTPs and FTPs it returns solely PTPs</p>
   *
   * <br>globaldefs::NamingAttributes_T managedElementName: The name of the 
   * Managed Element.
   * <br>transmissionParameters::LayerRateList_T tpLayerRateList: List of PTP 
   *  layer rates for which the PTPs are to be fetched. A PTP must contain at 
   *  least one of the layer rates specified to be reported.  If the list is 
   *  empty then PTPs of all rates are returned.
   * <br>transmissionParameters::LayerRateList_T connectionLayerRateList: List 
   *  of connection layer rates for which the PTPs are to be fetched. A PTP must 
   *  support connections for at least one of the
   *  layer rates specified to be reported.  If the list is empty then PTPs for 
   *  all connection rates are returned.
   * <br>unsigned long how_many: Maximum number of PTPs to return in the 
   * first batch.
   * <br>terminationPoint::TerminationPointList_T tpList: First batch of 
   * PTPs.
   * <br>terminationPoint::TerminationPointIterator_I tpIt: Iterator to 
   * retrieve remaining PTPs.
   * <br><b>Raises</b> globaldefs::ProcessingFailureException <br> 
   * As for getAllPTPs().
   **/
   void getAllPTPsWithoutFTPs(
         in globaldefs::NamingAttributes_T managedElementName,
         in transmissionParameters::LayerRateList_T tpLayerRateList,
         in transmissionParameters::LayerRateList_T connectionLayerRateList,
         in unsigned long how_many,
         out terminationPoint::TerminationPointList_T tpList,
         out terminationPoint::TerminationPointIterator_I tpIt) 
        raises(globaldefs::ProcessingFailureException);

  /**
   * <p>Note: This interface has been added in version 3 to return FTPs 
   * only. It allows more selective retrieval than the modified 
   * getAllPTPs() which now returns PTPs and FTPs. </p>
   * <p>This operation has exactly the same behaviour as 
   * getAllPTPs(), but instead of returning both PTPs and FTPs it returns 
   * solely FTPs</p>
   *
   * <br>globaldefs::NamingAttributes_T managedElementName: The name of the 
   * Managed Element.
   * <br>transmissionParameters::LayerRateList_T tpLayerRateList: List of FTP 
   *  layer rates for which the FTPs are to be fetched. A FTP must contain at 
   *  least one of the layer rates specified to be reported.  If the list is 
   *  empty then FTPs of all rates are returned.
   * <br>transmissionParameters::LayerRateList_T connectionLayerRateList: List 
   *  of connection layer rates for which the FTPs are to be fetched. A FTP must 
   *  support connections for at least one of the
   *  layer rates specified to be reported.  If the list is empty then FTPs for 
   *  all connection rates are returned.
   * <br>unsigned long how_many: Maximum number of FTPs to return in the 
   *  first batch.
   * <br>terminationPoint::TerminationPointList_T tpList: First batch of 
   *  FTPs.
   * <br>terminationPoint::TerminationPointIterator_I tpIt: Iterator to 
   *  retrieve remaining FTPs.
   * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
   * As for getAllPTPs().
   **/
   void getAllFTPs(
         in globaldefs::NamingAttributes_T managedElementName,
         in transmissionParameters::LayerRateList_T tpLayerRateList,
         in transmissionParameters::LayerRateList_T connectionLayerRateList,
         in unsigned long how_many,
         out terminationPoint::TerminationPointList_T tpList,
         out terminationPoint::TerminationPointIterator_I tpIt) 
        raises(globaldefs::ProcessingFailureException);


  /**
   * <p>Note: This interface has been enhanced in version 3 to return both PTPs 
   * and FTPs (maximising inter-version compatibility). Two new operations have 
   * been added to getAllPTPNamesWithoutFTPs() and getAllFTPNames()
   * to allow more selective retrieval. </p>
   * <p>This operation has exactly the same behaviour as getAllPTPs(), but
   * instead of returning the entire object structures, this operation returns 
   * their names.</p>
   *
   * <br>globaldefs::NamingAttributes_T managedElementName: The name of the 
   * Managed Element.
   * <br>transmissionParameters::LayerRateList_T tpLayerRateList: List of 
   *  PTP/FTP layer rates for which the PTPs/FTPs are to be fetched. A PTP/FTP 
   *  must contain at least one of the layer rates specified to be reported.  If 
   *  the list is empty then PTPs/FTPs of all rates are returned.
   * <br>transmissionParameters::LayerRateList_T connectionLayerRateList: List 
   *  of connection layer rates for which the PTPs/FTPs are to be fetched. A 
   *  PTP/FTP must support connections for at least one of the
   *  layer rates specified to be reported.  If the list is empty then PTPs/FTPs 
   *  for all connection rates are returned.
   * <br>unsigned long how_many: Maximum number of PTPs/FTPs to return in 
   *  the first batch.
   * <br>globaldefs::NamingAttributesList_T nameList: First batch of 
   *  PTPs/FTPs.
   * <br>globaldefs::NamingAttributesIterator_I nameIt: Iterator to retrieve 
   *  the remaining PTPs/FTPs.
   * <br><b>Raises</b> globaldefs::ProcessingFailureException <br> 
   * As for getAllPTPs().
   **/
   void getAllPTPNames(
         in globaldefs::NamingAttributes_T managedElementName, 
         in transmissionParameters::LayerRateList_T tpLayerRateList,
         in transmissionParameters::LayerRateList_T connectionLayerRateList,
         in unsigned long how_many,
         out globaldefs::NamingAttributesList_T nameList,
         out globaldefs::NamingAttributesIterator_I nameIt)
        raises(globaldefs::ProcessingFailureException);

  /**
   * <p>Note: This interface has been added in version 3 to return PTP 
   * names only. It allows more selective retrieval than the modified 
   * getAllPTPNames() which now returns PTP and FTP names. </p>
   * <p>This operation has exactly the same behaviour as 
   * getAllPTPsWithoutFTPs(), but
   * instead of returning the entire object structures, this operation returns 
   * their names.</p>
   *
   * <br>globaldefs::NamingAttributes_T managedElementName: The name of the 
   * Managed Element.
   * <br>transmissionParameters::LayerRateList_T tpLayerRateList: List of PTP 
   *  layer rates for which the PTPs are to be fetched. A PTP must contain at 
   *  least one of the layer rates specified to be reported.  If the list is 
   *  empty then PTPs of all rates are returned.
   * <br>transmissionParameters::LayerRateList_T connectionLayerRateList: List 
   *  of connection layer rates for which the PTPs are to be fetched. A PTP must 
   *  support connections for at least one of the
   *  layer rates specified to be reported.  If the list is empty then PTPs for 
   *  all connection rates are returned.
   * <br>unsigned long how_many: Maximum number of PTPs to return in the 
   *  first batch.
   * <br>globaldefs::NamingAttributesList_T nameList: First batch of PTPs.
   * <br>globaldefs::NamingAttributesIterator_I nameIt: Iterator to retrieve 
   *  the remaining PTPs.
   * <br><b>Raises</b> globaldefs::ProcessingFailureException <br> 
   * As for getAllPTPs().
   **/
   void getAllPTPNamesWithoutFTPs(
         in globaldefs::NamingAttributes_T managedElementName, 
         in transmissionParameters::LayerRateList_T tpLayerRateList,
         in transmissionParameters::LayerRateList_T connectionLayerRateList,
         in unsigned long how_many,
         out globaldefs::NamingAttributesList_T nameList,
         out globaldefs::NamingAttributesIterator_I nameIt)
        raises(globaldefs::ProcessingFailureException);

  /**
   * <p>Note: This interface has been added in version 3 to return FTP 
   * names only. It allows more selective retrieval than the modified 
   * getAllPTPNames() which now returns PTP and FTP names. </p>
   * <p>This operation has exactly the same behaviour as getAllFTPs(),
   * but instead of returning the entire object structures, this 
   * operation returns their names.</p>
   *
   * <br>globaldefs::NamingAttributes_T managedElementName: The name of the 
   * Managed Element.
   * <br>transmissionParameters::LayerRateList_T tpLayerRateList: List of FTP 
   *  layer rates for which the FTPs are to be fetched. A FTP must contain at 
   *  least one of the layer rates specified to be reported.  If the list is 
   *  empty then FTPs of all rates are returned.
   * <br>transmissionParameters::LayerRateList_T connectionLayerRateList: List 
   *  of connection layer rates for which the FTPs are to be fetched. A FTP must 
   *  support connections for at least one of the
   *  layer rates specified to be reported.  If the list is empty then FTPs for 
   *  all connection rates are returned.
   * <br>unsigned long how_many: Maximum number of FTPs to return in the 
   *  first batch.
   * <br>globaldefs::NamingAttributesList_T nameList: First batch of FTPs.
   * <br>globaldefs::NamingAttributesIterator_I nameIt: Iterator to retrieve 
   *  the remaining FTPs.
   * <br><b>Raises</b> globaldefs::ProcessingFailureException <br> 
   * As for getAllPTPs().
   **/
   void getAllFTPNames (
         in globaldefs::NamingAttributes_T managedElementName, 
         in transmissionParameters::LayerRateList_T tpLayerRateList,
         in transmissionParameters::LayerRateList_T connectionLayerRateList,
         in unsigned long how_many,
         out globaldefs::NamingAttributesList_T nameList,
         out globaldefs::NamingAttributesIterator_I nameIt)
        raises(globaldefs::ProcessingFailureException);


  /** 
   * <p>This service returns the termination point structure for the given TP 
   * name (CTP, FTP or PTP). The termination point name must be explicit (a 
   * generic endpoint specification may not be used in this case). See 
   * <a href=../../../supportingDocumentation/SD1-25_objectNaming.pdf >SD1-25 
   * Object Naming</a> for further detail on FTP naming.
   * The termination point structure contains <a 
   * href=../../../supportingDocumentation/SD1-16_LayeredParameters.pdf >SD1-16 transmission 
   * parameters</a>. The transmission parameters returned will be the parameters
   * in place on the actual termination point on the NE.  If there are no
   * transmission parameters or the TP does not actually exist on the NE,
   * then transmissionParams will be empty. The field transmissionParams
   * will also be empty for "potential" ATM VP/VC CTPs.</p>
   * <br>globaldefs::NamingAttributes tpName: Name of the TP to retrieve.
   * <br>terminationPoint::TerminationPoint_T tp: The retrieved TP.
   * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
   *  failure<br>
   * EXCPT_INVALID_INPUT - Raised when tpName does not reference a termination 
   *  point object<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when tpName references a TP object that 
   *  does not exist<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
   *  lost<br>
   * <br>
   **/
   void getTP(
         in globaldefs::NamingAttributes_T tpName,
         out terminationPoint::TerminationPoint_T tp) 
        raises (globaldefs::ProcessingFailureException);


  /** 
   * <p>This service returns the Managed Element for the given managed element 
   * name.</p>
   * <br>globaldefs::NamingAttributes managedElementName: Name of the ME to 
   *  retrieve.
   * <br>managedElement::ManagedElement_T me: The retrieved ME.
   * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
   *  failure<br>
   * EXCPT_INVALID_INPUT - Raised when managedElementName does not reference a
   *  managed element object<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when managedElementName references an ME 
   *  object that does not exist<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to the managed element is 
   *  lost<br>
   * <br>
   **/
   void getManagedElement(
         in globaldefs::NamingAttributes_T managedElementName,
         out managedElement::ManagedElement_T me) 
        raises (globaldefs::ProcessingFailureException);


  /**
   * <p>This allows an NMS to request all of the CTPs that it is potentially 
   * capable of supporting in all possible mapping configurations, at the 
   * specified rates and that are contained by the
   * specified termination point.</p>
   *
   * <p>This service returns all potential contained CTPs for a given TP. The TP 
   * may be a PTP, an FTP or a CTP. If the layerRateList is empty then 
   * contained CTPs at all flexible and/or static LayerRates are 
   * returned.</p>
   *
   * <p>For an OC3 PTP that has the potential of mapping to 
   * VT1.5 the response would contain 3 STS1 CTPs and 84 VT1.5 CTPs;
   * on a T1 PTP, the contained TPs would be one T1 CTP; for
   * an STS1 CTP the response would contain 28 VT1.5 CTPs.  
   * In the case where an OC3 PTP supports mapping 
   * to T1s and VT1.5,
   * then the contained list for the OC3 PTP
   * could be 1 STS3c, 3 STS1, 84 VT1.5 and 84 T1 CTPs;  
   * if a VT1.5 CTP is provided, 1 T1 CTP is returned;
   * if a T1 CTP is provided, the result is an empty list.</p>
   *
   * <p>Whenever a protection group is involved, the behaviour of
   * this service is described below:</p>
   *
   * <TABLE BORDER=2 COLS=2 WIDTH="80%">
   * <TR>
   * <TD>Scenario</TD><TD>Query On Worker TPs </TD><TD>Query On Protection 
   * TPs</TD>
   * </TR>
   * <TR>
   * <TD>Before the Protection Group is created</TD>
   * <TD>returns list of all CTPs </TD>
   * <TD>returns list of all CTPs</TD>
   * </TR>
   * <TR>
   * <TD>After ProtectionGroup is created, if extra 
   * (preemptible/non-pre-emptible) traffic is allowed.</TD>
   * <TD>returns list of all CTPs </TD>
   * <TD>returns list of all CTPs</TD>
   *</TR>
   * <TR>
   * <TD>After ProtectionGroup is created, if extra 
   * (preemptible/non-pre-emptible) traffic is not allowed </TD>
   * <TD>returns list of CTPs that allow protected traffic</TD>
   * <TD>returns an empty list (regardless of the switch status)</TD>
   * </TR>
   * </TABLE>
   * 
   * <p>In case the protection group is created after a query is made, 
   * no object delete notification is 
   * made, the NMS is expected to query the ports in the protection group 
   * to find the list of contained CTPs.</p>
   *
   * <p>When an NMS is interacting with an EMS that supports ATM, this operation
   * needs to be used with caution. The reason for this is that, in ATM, there
   * can be a prohibitively large number of potential VP and VC CTPs returned
   * by this operation. For retrieving ATM CTPs, the getContainedInUseTPs()
   * operation should be considered.</p>
   *
   * <p>If DWDM, SONET and/or SDH is combined with ATM, it is advisable that 
   * this operation be used with the appropriate DWDM, SONET and/or SDH layer  
   * rates entered into the layerRateList. Otherwise, ATM CTPs will be returned 
   * and the resulting list of contained TPs could get prohibitive.</p>
   * 
   * <p>For details on how TPs should be modelled, see
   * <a href=../../../supportingDocumentation/SD1-18_layers.pdf >
   * SD1-18 Functional Modelling Concepts</a>.</p>
   *
   * <p>In order to allow the NMS to deal with a large number of objects,
   * this operation uses an iterator. See
   * <a href=../../../supportingDocumentation/SD1-15_iterators.pdf >SD1-15 iterator overview</a>
   * for information on how iterators are used in this interface.</p>
   * 
   * <br>globaldefs::NamingAttributes_T tpName: The name of the PTP, FTP or 
   *  CTP for which to get contained CTPs. The 
   * termination point name must be explicit (a generic endpoint specification 
   * may not be used in this case). See 
   * <a href=../../../supportingDocumentation/SD1-25_objectNaming.pdf >SD1-25 
   * Object Naming</a> for further detail on FTP naming.
   * <br>transmissionParameters::LayerRateList_T layerRateList: The list of 
   *  the rates of the contained CTPs to report. An 
   *  empty list indicates to the EMS to report all contained CTPs (of all 
   *  rates).
   * <br>unsigned long how_many: Maximum number of contained CTPs to report in 
   *  the first batch.
   * <br>TerminationPointList_T tpList: First batch of contained CTPs.
   * <br>TerminationPointIterator_I tpIt: Iterator to retrieve the remaining 
   *  contained CTPs.
   * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
   * EXCPT_NOT_IMPLEMENTED - Raised if EMS cannot support this service<br>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
   *  failure<br>
   * EXCPT_INVALID_INPUT - Raised when tpName does not reference a PTP, FTP or 
   *  CTP object or layerRateList contains undefined rates<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when tpName references a PTP, FTP or CTP 
   *  object that does not exist<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
   *  lost<br>
   * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators 
   *  that the EMS can support has been reached<br>
   * <br>
   **/
   void getContainedPotentialTPs(
         in globaldefs::NamingAttributes_T tpName,
         in transmissionParameters::LayerRateList_T layerRateList,
         in unsigned long how_many,
         out terminationPoint::TerminationPointList_T tpList, 
         out terminationPoint::TerminationPointIterator_I tpIt)
        raises(globaldefs::ProcessingFailureException);



  /** 
   * <p>This operation has exactly the same behaviour as 
   * getContainedPotentialTPs(), but instead of returning the entire object 
   * structures, this operation returns their names.</p>
   *
   * <p>In order to allow the NMS to deal with a large number of objects,
   * this operation uses an iterator. See
   * <a href=../../../supportingDocumentation/SD1-15_iterators.pdf >SD1-15 iterator overview</a>
   * for information on how iterators are used in this interface.</p>
   * 
   * <br>globaldefs::NamingAttributes_T tpName: Name of the PTP, FTP or CTP 
   * for which to get contained CTPs. The 
   * termination point name must be explicit (a generic endpoint specification 
   * may not be used in this case). See 
   * <a href=../../../supportingDocumentation/SD1-25_objectNaming.pdf >SD1-25 
   * Object Naming</a> for further detail on FTP naming.
   * <br>transmissionParameters::LayerRateList_T layerRateList: the list of 
   * the rates of the contained CTPs to be reported. An 
   * empty list indicates to the EMS to get all contained CTPs (of all rates).
   * <br>unsigned long how_many: Maximum number of contained CTPs to return 
   * in the first batch.
   * <br>globaldefs::NamingAttributesList_T nameList: First batch of 
   * contained CTPs.
   * <br>globaldefs::NamingAttributesListIterator_I nameIt: Iterator to 
   * retrieve the remaining contained CTPs.
   * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
   * As for getContainedPotentialTPs().
   **/
   void getContainedPotentialTPNames(
         in globaldefs::NamingAttributes_T tpName,
         in transmissionParameters::LayerRateList_T layerRateList,
         in unsigned long how_many,
         out globaldefs::NamingAttributesList_T nameList,
         out globaldefs::NamingAttributesIterator_I nameIt)
        raises(globaldefs::ProcessingFailureException);


  /** 
   * <p>This service is used to retrieve the "in use" CTPs that are contained 
   * within a specific PTP, FTP or CTP, at specific layer rates. 
   * An "in use" CTP is defined as a CTP that is used by an SNC
   * in any state (including pending), either as a CM end point or as an 
   * intermediate connection point, or a CTP that is terminated and mapped.
   * This operation will be used when there are a large number of potential CTPs
   * (e.g., in ATM).</p>
   *
   * <p>Example of usage with respect to ATM:<br>
   * To retrieve all actual ATM Network Interfaces associated with a PTP,
   * this operation will be invoked using the PTP name as the tpName and
   * LR_ATM_NI as the only layer rate in the layerRateList. The VPI and
   * VCI ranges that are specified in the returned ATM Network Interface
   * transmissionParams (i.e., Max_VPI_Bits and Max_VCI_Bits) can then be
   * used to determine the potential VPI/VCI range. A subsequent invocation of
   * this operation using an ATM Network Interface CTP as input can be used to
   * determine which VPIs/VCIs are actually in use (with LR_ATM_VP and LR_ATM_VC
   * included in the connectionRateList).<br></p>
   *
   * <p>Example of usage with respect to SONET/SDH:<br>
   * Consider an STM4 PTP with layerRate: LR_Optical_OC12_and_STM4.
   * Assume that the set of CTPs returned by operation 
   * getContainedPotentialTPs()
   * contains one CTP with layerRate LR_STS3c_and_AU4_VC4 that is terminating
   * an SNC (layerRate LR_STS3c_and_AU4_VC4), and another CTP with layerRate
   * LR_STS3c_and_AU4_VC4 that is terminated and mapped (attribute
   * tpMappingMode is set to TM_TERMINATED_AND_AVAILABLE_FOR_MAPPING).
   * The CTP with layerRate LR_STS3c_and_AU4_VC4 that is terminated and mapped
   * contains one CTP with layerRate LR_VT2_and_TU12_VC12
   * that is involved in an SNC. None of the other contained CTPs have attribute
   * tpMappingMode set to TM_TERMINATED_AND_AVAILABLE_FOR_MAPPING, or are
   * involved in an SNC.<br>
   * Operation getContainedInUseTPs then returns three CTPs:<ul>
   * <li>The CTP with layerRate LR_STS3c_and_AU4_VC4 that is terminating an 
   * SNC.</li>
   * <li>The CTP with layerRate LR_STS3c_and_AU4_VC4 that has attribute
   * tpMappingMode set to TM_TERMINATED_AND_AVAILABLE_FOR_MAPPING.</li>
   * <li>The CTP with layerRate LR_VT2_and_TU12_VC12 that is terminating an 
   * SNC.</li>
   * </ul><br></p>
   * 
   * <p>For details on how TPs should be modelled, see
   * <a href=../../../supportingDocumentation/SD1-18_layers.pdf >
   * SD1-18 Functional Modelling Concepts</a>.</p>
   *
   * <p>In order to allow the NMS to deal with a large number of objects,
   * this operation uses an iterator. See
   * <a href=../../../supportingDocumentation/SD1-15_iterators.pdf >SD1-15 iterator overview</a>
   * for information on how iterators are used in this interface.</p>
   * 
   * <br>globaldefs::NamingAttributes_T tpName: The name of the PTP, FTP or 
   *  CTP for which to get contained actual CTPs. The 
   * termination point name must be explicit (a generic endpoint specification 
   * may not be used in this case). See 
   * <a href=../../../supportingDocumentation/SD1-25_objectNaming.pdf >SD1-25 
   * Object Naming</a> for further detail on FTP naming.
   * <br>transmissionParameters::LayerRateList_T layerRateList: The list of 
   * rates of the contained actual CTPS to be returned.
   * An empty list indicates to the EMS to get all contained actual CTPs (for 
   * all rates).
   * <br>unsigned long how_many: The maximum number of CTPs to be returned in 
   * the first batch.
   * <br>TerminationPointList_T tpList: First batch of contained in use CTPs.
   * <br>TerminationPointIterator_I tpIt: Iterator to retrieve the remaining
   * contained in use CTPs.
   * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
   *  failure<br>
   * EXCPT_INVALID_INPUT - Raised when tpName does not reference a PTP, FTP or 
   *  CTP object or layerRateList contains undefined rates<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when tpName references a PTP, FTP or CTP 
   *  object that does not exist<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
   *  lost<br>
   * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators 
   *  that the EMS can support has been reached<br>
   * <br>
   **/
   void getContainedInUseTPs(
         in globaldefs::NamingAttributes_T tpName,
         in transmissionParameters::LayerRateList_T layerRateList,
         in unsigned long how_many,
         out terminationPoint::TerminationPointList_T tpList, 
         out terminationPoint::TerminationPointIterator_I tpIt)
        raises(globaldefs::ProcessingFailureException);


  /**
   * <p>This operation has exactly the same behaviour as 
   * getContainedInUseTPs(), but
   * instead of returning the entire object structures, this operation returns 
   * their names.</p>
   *
   * <p>In order to allow the NMS to deal with a large number of objects,
   * this operation uses an iterator. See
   * <a href=../../../supportingDocumentation/SD1-15_iterators.pdf >SD1-15 iterator overview</a>
   * for information on how iterators are used in this interface.</p>
   * 
   * <br>globaldefs::NamingAttributes_T tpName: The name of the TP for which 

   * to get contained in use TPs. The termination point name must be explicit (a 
   * generic endpoint specification may not be used in this case). See 
   * <a href=../../../supportingDocumentation/SD1-25_objectNaming.pdf >SD1-25 
   * Object Naming</a> for further detail on FTP naming.
   * <br>transmissionParameters::LayerRateList_T layerRateList: The list of 
   * rates of the contained in use CTPs to be returned. An 
   * empty list indicates to the EMS to get all contained in use CTPs (of all 
   * rates).
   * <br>unsigned long how_many: Maximum number of CTP names to be returned in 
   * the first batch.
   * <br>globaldefs::NamingAttributesList_T nameList: First batch of CTP 
   * names.
   * <br>globaldefs::NamingAttributesListIterator_I nameIt: Iterator to 
   * retrieve the remaining CTP names.
   * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
   * As for getContainedInUseTPs().
   **/
   void getContainedInUseTPNames(
         in globaldefs::NamingAttributes_T tpName,
         in transmissionParameters::LayerRateList_T layerRateList,
         in  unsigned long how_many,
         out globaldefs::NamingAttributesList_T nameList,
         out globaldefs::NamingAttributesIterator_I nameIt)
        raises(globaldefs::ProcessingFailureException);


  /** 
   * <p>This service is used to retrieve the "current" CTPs that are contained 
   * within a specific PTP, FTP or CTP, at specific layer rates. 
   * A "current" CTP is defined as a CTP that is either cross-connectable or 
   * cross-connected,in the current mapping configuration. </p>
   *
   * <p>In order to allow the NMS to deal with a large number of objects,
   * this operation uses an iterator. See
   * <a href=../../../supportingDocumentation/SD1-15_iterators.pdf >SD1-15 iterator overview</a>
   * for information on how iterators are used in this interface.</p>
   * 
   * <br>globaldefs::NamingAttributes_T tpName: The name of the PTP, FTP or 
   *  CTP for which to get current contained CTPs. The 
   * termination point name must be explicit (a generic endpoint specification 
   * may not be used in this case). See 
   * <a href=../../../supportingDocumentation/SD1-25_objectNaming.pdf >SD1-25 
   * Object Naming</a> for further detail on FTP naming.
   * <br>transmissionParameters::LayerRateList_T layerRateList: The list of 
   * rates of the current contained CTPS to be returned.
   * An empty list indicates to the EMS to get all current contained CTPs (of 
   * all rates).
   * <br>unsigned long how_many: The maximum number of CTPs to be returned in 
   * the first batch.
   * <br>TerminationPointList_T tpList: First batch of contained current CTPs.
   * <br>TerminationPointIterator_I tpIt: Iterator to retrieve the remaining
   * contained current CTPs.
   * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
   * EXCPT_NOT_IMPLEMENTED - Raised if EMS cannot support this service<br>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
   *  failure<br>
   * EXCPT_INVALID_INPUT - Raised when tpName does not reference a PTP, FTP or 
   *  CTP object or layerRateList contains undefined rates<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when tpName references a PTP, FTP or CTP 
   *  object that does not exist<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
   *  lost<br>
   * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators 
   *  that the EMS can support has been reached<br>
   * <br>
   **/
   void getContainedCurrentTPs(
         in globaldefs::NamingAttributes_T tpName,
         in transmissionParameters::LayerRateList_T layerRateList,
         in unsigned long how_many,
         out terminationPoint::TerminationPointList_T tpList, 
         out terminationPoint::TerminationPointIterator_I tpIt)
        raises(globaldefs::ProcessingFailureException);


  /**
   * <p>This operation has exactly the same behaviour as 
   * getContainedCurrentTPs(), but instead of returning the entire object 
   * structures, this operation returns their names.</p>
   *
   * <p>In order to allow the NMS to deal with a large number of objects,
   * this operation uses an iterator. See
   * <a href=../../../supportingDocumentation/SD1-15_iterators.pdf >SD1-15 iterator overview</a>
   * for information on how iterators are used in this interface.</p>
   * 
   * <br>globaldefs::NamingAttributes_T tpName: The name of the PTP, FTP or 
   *  CTP for which to get current contained CTPs. The 
   * termination point name must be explicit (a generic endpoint specification 
   * may not be used in this case). See 
   * <a href=../../../supportingDocumentation/SD1-25_objectNaming.pdf >SD1-25 
   * Object Naming</a> for further detail on FTP naming.
   * <br>transmissionParameters::LayerRateList_T layerRateList: The list of 
   * rates of the current contained CTPS to be returned.
   * An empty list indicates to the EMS to get all current contained CTPs (of 
   * all rates).
   * <br>unsigned long how_many: Maximum number of CTP names to be returned in 
   * the first batch.
   * <br>globaldefs::NamingAttributesList_T nameList: First batch of CTP 
   * names.
   * <br>globaldefs::NamingAttributesListIterator_I nameIt: Iterator to 
   * retrieve the remaining CTP names.
   * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
   * As for getContainedCurrentTPs().
   **/
   void getContainedCurrentTPNames(
         in globaldefs::NamingAttributes_T tpName,
         in transmissionParameters::LayerRateList_T layerRateList,
         in  unsigned long how_many,
         out globaldefs::NamingAttributesList_T nameList,
         out globaldefs::NamingAttributesIterator_I nameIt)
        raises(globaldefs::ProcessingFailureException);


  /**
   * <p>This service returns a list of the containing TPs given a CTP. This 
   * will return an PTP or FTP where there is only one level of containment. In 
   * a case of deeper containment this will return a list of CTPs and a PTP or 
   * FTP. 
   * Using the UPSR OC3 example used in getContainedPotentialTPs, 
   * getContainingTPs on the working T1 CTP will return a working STS1 CTP and a 
   * working OC3PTP.
   * If the OC3 was in APS, then getContainingTPs on the T1 CTP would return
   * an STS1 CTP, an OC3 working PTP and an OC3 protect PTP. 
   * 
   * <p>For details on how TPs should be modelled, see
   * <a href=../../../supportingDocumentation/SD1-18_layers.pdf >
   * SD1-18 Functional Modelling Concepts</a>.</p>
   *
   * <br>globaldefs::NamingAttributes tpName: Name of the CTP for which 
   * containing CTPs and PTP/FTP are to be reported. The 
   * termination point name must be explicit (a generic endpoint specification 
   * may not be used in this case). See 
   * <a href=../../../supportingDocumentation/SD1-25_objectNaming.pdf >SD1-25 
   * Object Naming</a> for further detail on FTP naming.
   * <br>terminationPoint::TerminationPointList_T tpList: List of the 
   * containing CTPs and PTPs.
   * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
   * EXCPT_NOT_IMPLEMENTED - Raised if EMS cannot support this service<br>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
   *  failure<br>
   * EXCPT_INVALID_INPUT - Raised when tpName does not reference a CTP 
   *  object<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when tpName references a CTP object that 
   *  does not exist<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
   *  lost<br>
   * <br>
   **/
   void getContainingTPs(
         in globaldefs::NamingAttributes_T tpName,
         out terminationPoint::TerminationPointList_T tpList)
        raises (globaldefs::ProcessingFailureException);


  /**
   * <p>This operation has exactly the same behaviour as 
   * getContainingTPs(), but
   * instead of returning the entire object structures, this operation returns 
   * their names.</p>
   *
   * <br>globaldefs::NamingAttributes_T tpName: Name of the CTP for which 
   * to get the names of the containing TPs.
   * <br>globaldefs::NamingAttributesList_T tpNameList: List of the names of 
   * the containing TPs.
   * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
   * As for getContainingTPs().
   **/
   void getContainingTPNames(
         in globaldefs::NamingAttributes_T tpName,
         out globaldefs::NamingAttributesList_T tpNameList)
        raises (globaldefs::ProcessingFailureException);


  /**
   * <p>This allows an NMS to request all of the active alarms and TCAs 
   * for the specified managed element.
   * Alarms that are not reported by the ME to the EMS should not be reported by 
   * this operation. Some alarms may be
   * filtered out (excluded) by specifying their probable causes or severities.
   * </p>
   *
   * <p>The result of this operation is independent of the filtering set up by 
   * the NMS for the notification service. Alarms which ASAP assigned severity 
   * is "NOTALARMED" should not be reported by this operation. </p>
   *
   * <br>globaldefs::NamingAttributes meName: The name of the 
   * Managed Element for which to retrieve alarms and TCAs.
   * <br>notifications::ProbableCauseList_T excludeProbCauseList: List of 
   * probable causes to exclude from the output event list.
   * <br>notifications::PerceivedSeverityList_T excludeSeverityList: List of 
   * severities to exclude from the output event list.
   * <br>unsigned long how_many: Maximum number of events to report in the 
   * first batch.
   * <br>notifications::EventList_T eventList: First batch of events.
   * <br>notifications::EventIterator_I eventIt: Iterator to retrieve the 
   * remaining events.
   * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
   *  failure<br>
   * EXCPT_INVALID_INPUT - Raised when meName does not reference a managed 
   *  element object or excludeProbCauseList or excludeSeverityList contains 
   *  undefined values<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when meName references an ME object that 
   *  does not exist<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
   *  lost<br>
   * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators 
   *  that the EMS can support has been reached<br>
   * <br>
   **/
   void getAllActiveAlarms(
        in globaldefs::NamingAttributes_T meName,
        in notifications::ProbableCauseList_T excludeProbCauseList,
        in notifications::PerceivedSeverityList_T excludeSeverityList,
        in unsigned long how_many,
        out notifications::EventList_T eventList,
        out notifications::EventIterator_I eventIt) 
	 raises(globaldefs::ProcessingFailureException);


  /**
   * <p>This allows an NMS to request all of the active  alarms and TCAs 
   * for the specified managed element that have not been acknowledged.
   * Alarms that are not reported by the ME to the EMS should not be reported by 
   * this operation. Some alarms may be
   * filtered out (excluded) by specifying their probable causes or severities.
   * </p>
   *
   * <p>The result of this operation is independent of the filtering set up by 
   * the NMS for the notification service. Alarms which ASAP assigned severity 
   * is "NOTALARMED" should not be reported by this operation. </p>
   *
   * <br>globaldefs::NamingAttributes meName: The name of the 
   * Managed Element for which to retrieve unacknowledged alarms and TCAs.
   * <br>notifications::ProbableCauseList_T excludeProbCauseList: List of 
   * probable causes to exclude from the output event list.
   * <br>notifications::PerceivedSeverityList_T excludeSeverityList: List of 
   * severities to exclude from the output event list.
   * <br>unsigned long how_many: Maximum number of events to report in the 
   * first batch.
   * <br>notifications::EventList_T eventList: First batch of events.
   * <br>notifications::EventIterator_I eventIt: Iterator to retrieve the 
   * remaining events.
   * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
   * EXCPT_NOT_IMPLEMENTED - Raised if the EMS does not support this service<br>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
   *  failure<br>
   * EXCPT_INVALID_INPUT - Raised when meName does not reference a managed 
   *  element object or excludeProbCauseList ofr excludeSeverityList contains 
   *  undefined values<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when meName references an ME object that 
   *  does not exist<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
   *  lost<br>
   * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators 
   *  that the EMS can support has been reached<br>
   * <br>
   **/
   void getAllUnacknowledgedActiveAlarms(
        in globaldefs::NamingAttributes_T meName,
        in notifications::ProbableCauseList_T excludeProbCauseList,
        in notifications::PerceivedSeverityList_T excludeSeverityList,
        in unsigned long how_many,
        out notifications::EventList_T eventList,
        out notifications::EventIterator_I eventIt)
       raises(globaldefs::ProcessingFailureException);


  /** 
   * <p>This service allows the NMS to set parameters on a specified 
   * Termination Point (CTP, PTP or FTP). See <a 
   * href=../../../supportingDocumentation/SD1-16_LayeredParameters.pdf >SD1-16 
   * Layered Transmission Parameters</a> for further information.</p>
   *
   * <p>This operation is best effort (except where specified otherwise for a 
   * particular parameter). The results of the operation are returned
   * so that the NMS is aware of what modifications succeeded.</p>
   *
   * <p>If the source TP of a broadcast system is used as input, then
   * the entire multipoint system will be affected based on the new
   * parameter values for the source TP.</p>
   *
   * <p>The tpMappingMode may be set with this operation. When the mode is
   * set to TM_TERMINATED_AND_AVAILABLE_FOR_MAPPING, the EMS will terminate the
   * specified CTP. In this case the EMS must create the specified CTP on 
   * the NE if it does not actually exist. 
   * Setting the tpMappingMode of an ATM VP or VC CTP can only be done if
   * the CTP has been created. Note that the tpMappingMode can be set
   * only on the ingress and egress CTPs of an ATM SNC since they are the only
   * ones which may not be cross-connected.</p>
   *
   * <p>No change to tpMappingMode or trafficDescriptors will take place if
   * there is any active cross connect (NE cross connect)
   * using the CTP passed in parameter.</p>
   *
   * <p>The transmissionParams is a "delta" list that needs to be
   * applied to the specified TP, i.e. only a subset of the
   * parameters may be specified in the list, in which case only those
   * should be applied in the NE. Transmission parameters are used to associate 
   * a TCA profile with a TP using this service. In this case there are 
   * potentially additional failure modes (see exceptions).</p>
   *
   * <p> The assignment of a Transmission Descriptor (TMD) to a Termination Point (TP) 
   * as egress or ingress TMD by using the TMD's name amounts to an overwriting 
   * of the layered transmission parameters of the TP by the layered transmission 
   * parameters of the TMD, and to an overwriting of the additional info parameters
   * of the TP by the "additional TP information" parameters of the TMD. </p>
   *
   * <br>subnetworkConnection::TPData_T tpInfo: Details of modifications 
   * required.
   * <br>terminationPoint::TerminationPoint_T modifiedTP: Result of 
   * modification.
   * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
   *  failure<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised if the TP referred to in tpInfo does not 
   *  exist.<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
   *  lost<br>
   * EXCPT_INVALID_INPUT - Raised when an input parameter is syntactical 
   *  incorrect and raised when a parameter is identified as only "settable" 
   *  using a "specific operation" in the <a 
   *  href=../../../supportingDocumentation/SD1-16_LayeredParameters.pdf >SD1-16 
   *  Layered Transmission Parameters</a> document<br>
   * EXCPT_UNABLE_TO_COMPLY - Raised when the EMS is unable 
   *  to execute the request because at least one of the parameters although 
   *  valid can not be set and that parameter is identified as "not best effort" 
   *  in the <a href=../../../supportingDocumentation/SD1-16_LayeredParameters.pdf >SD1-16 
   *  Layered Transmission Parameters</a> document<br>
   * <br>
   **/
   void setTPData(
         in subnetworkConnection::TPData_T tpInfo,
         out terminationPoint::TerminationPoint_T modifiedTP)
        raises(globaldefs::ProcessingFailureException);


  /**
   * <p>This allows an NMS to request a list of the cross-connects for the 
   * specified managed element at the specified layer rates. This operation
   * returns cross-connects between CTPs/FTPs and between GTPs (GTP 
   * cross-connects are described in
   * <a href=../../../supportingDocumentation/SD1-3_BundledSNC.pdf >SD1-3 Bundled SNC 
   * overview</a>).</p>
   *
   * <p>In order to allow the NMS to deal with a large number of objects,   
   * this operation uses an iterator. See   
   * <a href=../../../supportingDocumentation/SD1-15_iterators.pdf >SD1-15 iterator overview</a>   
   * for information on how iterators are used in this interface.</p>
   * 
   * <br>globaldefs::NamingAttributes_T managedElementName: Name of the 
   * Managed Element for which to retrieve CCs.
   * <br>transmissionParameters::LayerRateList_T connectionRateList: List of 
   * rates for which to retrieve CCs. This must not be an empty list. In this 
   * case an INVALID_INPUT exception is thrown.
   * <br>in unsigned long how_many: Maximum number of CCs to report in the 
   * first batch.
   * <br>subnetworkConnection::CrossConnectList_T ccList: First batch of CCs.
   * <br>subnetworkConnection::CCIterator_I ccIt: Iterator to retrieve 
   * remaining CCs.
   * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
   *  failure<br>
   * EXCPT_INVALID_INPUT - Raised if connectionRateList is empty or contains
   *  invalid rates, or if managedElementName does not reference a managed 
   *  element.<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when managedElementName references an ME 
   *  object that does not exist<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
   *  lost<br>
   * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators 
   *  that the EMS can support has been reached<br>
   * <br>
   **/
   void getAllCrossConnections(
         in globaldefs::NamingAttributes_T managedElementName,
         in transmissionParameters::LayerRateList_T connectionRateList,
         in unsigned long how_many,
         out subnetworkConnection::CrossConnectList_T ccList,
         out subnetworkConnection::CCIterator_I ccIt)
        raises(globaldefs::ProcessingFailureException);

  /**
   * <p>The NMS uses this operation to request the creation of a GTP (see 
   * <a href=../../../supportingDocumentation/SD1-3_BundledSNC.pdf >SD1-3 Bundled SNC overview</a>
   * for further information on GTP usage). The NMS can either specify the list
   * of CTPs comprising the GTP (the list is placed in the listOfTPs parameter) 
   * or, in the case of contiguous CTPs of the same layerRate, the NMS may list 
   * the first CTP (in the initialCTPname parameter) and the number of 
   * following CTPs (in the numberOfCTPs parameter). The NMS 
   * may also provide the EMS with the flexibility to decide the list of CTPs  
   * by using the gtpEffort parameter. In this flexible mode the EMS uses the 
   * listOfTPs parameter or the initialCTPname/ numberOfCTPs parameters to 
   * determine the total requested bandwidth but it may return a GTP (newGTP 
   * parameter) with a different set of CTPs than those indicated in the 
   * original createGTP request. Note that this mode allows for the GTP 
   * components to be instantiated at a later time by the ME (e.g., upon 
   * detection of user's signal). Therefore the operation may successfully 
   * return a newGTP with an empty listOfTPs attribute (to be updated at a 
   * later time once the component CTPs are created in the ME).</p>
   *
   * <br>string userLabel: the userLabel for the GTP. 
   * <br>Boolean forceUniqueness: Specifies whether uniqueness of the userLabel 
   * is required amongst GTPs of the EMS.  The operation will fail if userLabel 
   * is already in use.
   * <br>string owner: the owner of the GTP. 
   * <br> globaldefs::NamingAttributesList_T listOfTPs: the list of CTPs that 
   * comprise the GTP. 
   * <br> globaldefs::NamingAttributesList_T initialCTPname: in cases where the 
   * CTPs are contiguous and of the same layerRate, this parameter is used to 
   * indicate the first CTP in the group. This parameter is used in lieu of the 
   * listOfTPs parameter.  
   * <br>unsigned long numberOfCTPs: This parameter is used in conjunction with 
   * the initialCTPname parameter. It indicates the number of contiguous CTPs 
   * that follow the initial CTP. It equals 1 minus the total number of CTPs in 
   * the GTP.
   * <br>terminationPoint::GTPEffort_T gtpEffort: This parameter is used to 
   * indicate if the GTP bandwidth specification can be met with a different 
   * list of CTPs. 
   * <br> globaldefs::NVSList_T additionalCreationInfo: This parameter contains 
   * additional information concerning the GTP create request. The list may be 
   * empty. For full information see <a 
   * href=../../../supportingDocumentation/SD1-1_additionalInfoUsage.pdf >SD1-1 
   * Additional Information Usage</a>. 
   * <br> terminationPoint::GTP_T newGTP: This output parameter contains the 
   * newly created GTP. 
   * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
   * EXCPT_NOT_IMPLEMENTED - Raised if the EMS does not support GTPs<br>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
   *  failure<br>
   * EXCPT_UNABLE_TO_COMPLY - Raised when the EMS cannot reply to the GTP 
   *  creation request<br>
   * EXCPT_INVALID_INPUT - Raised if the GTP creation data is not well 
   *  formed<br>
   * EXCPT_OBJECT_IN_USE - Raised if a CTP (to be included in the GTP) is being 
   *  used in an SNC, or is already in another GTP. <br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is lost 
   *  and this prevents creating the GTP<br>
   * <br>
   **/
   void createGTP(
         in string userLabel,
         in boolean forceUniqueness,
         in string owner,
         in globaldefs::NamingAttributesList_T listOfTPs,
         in globaldefs::NamingAttributes_T initialCTPname,
         in unsigned long numberOfCTPs,
         in terminationPoint::GTPEffort_T gtpEffort,
         in globaldefs::NVSList_T additionalCreationInfo,
         out terminationPoint::GTP_T newGTP)
        raises(globaldefs::ProcessingFailureException);


  /**
   * <p>The delete GTP operation is used to delete a GTP(see 
   * <a href=../../../supportingDocumentation/SD1-3_BundledSNC.pdf >SD1-3 Bundled SNC overview</a>
   * for further information on GTP usage). An attempt to delete a 
   * GTP that is involved in a cross connection or SNC should be rejected by the 
   * EMS. This operation is idempotent. If the service is called with the name 
   * of a non-existent GTP, it will succeed.</p>
   *
   * <br>globaldefs::NamingAttributes name of GTP to be deleted
   * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
   * EXCPT_NOT_IMPLEMENTED - Raised if EMS does not support deletion of GTPs via 
   *  this interface<br>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
   *  failure<br>
   * EXCPT_INVALID_INPUT - Raised when input parameter is syntactical 
   *  incorrect<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when the GTP to be deleted does not 
   *  exist<br>
   * EXCPT_OBJECT_IN_USE - Raised if the GTP is used in a cross connection<br>
   * <br>
   **/
   void deleteGTP(
	   in globaldefs::NamingAttributes_T gtpName)
        raises(globaldefs::ProcessingFailureException);

  /**
   * <p>The modify GTP operation is used to add TPs to or delete TPs from a GTP  
   * (see <a href=../../../supportingDocumentation/SD1-3_BundledSNC.pdf >SD1-3 Bundled SNC 
   * overview</a> for further information on GTP usage). 
   * For a given request, the NMS can only add or delete CTPs, not both. It 
   * is not possible to add a CTP that is already involved in a cross 
   * connection or SNC, or that is part of another GTP. Attempts to modify a GTP 
   * that is involved in a cross connection (or SNC) should be rejected by the 
   * EMS. The operation is best-effort, i.e., the EMS will add or delete as many 
   * of the identified CTPs as possible. 
   * If the service is called with the name of a non-existent GTP or CTP, it 
   * will fail.</p>
   *
   * <p>If the NMS created a GTP with gtpEffort equal to EFFORT_SAME, this also 
   * implies that the EMS will not modify on its own, i.e., the EMS will only 
   * modify the GTP if requested by the NMS via the modifyGTP operation.</p>
   *
   * <br>globaldefs::NamingAttribute gtpName: name of the GTP to be modified
   * <br>globaldefs::NamingAttributesList tpNames: names of the CTPs to be 
   * added or deleted
   * <br>string actionType: an indication of whether the listed TPs are to be 
   * added or deleted. Two values are possible "add" or "delete".
   * <br>terminationPoint::GTP_T modifiedGTP: the structure for the modified 
   * GTP
   * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
   * EXCPT_NOT_IMPLEMENTED - Raised if EMS does not support modification of GTPs 
   *  via this interface<br>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
   *  failure<br>
   * EXCPT_UNABLE_TO_COMPLY - Raised when the EMS cannot reply to the GTP 
   *  modification request.<br>
   * EXCPT_INVALID_INPUT - Raised if GTP modification data is not well 
   *  formed<br>
   * EXCPT_OBJECT_IN_USE - Raised if the GTP is part of a cross connection or 
   *  SNC<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when the GTP to be modified do not exist or 
   *  TPs to be added do not exist<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is lost 
   *  and this prevents modification of the GTP<br>
   * <br>
   **/
   void modifyGTP(
	   in globaldefs::NamingAttributes_T gtpName,
	   in globaldefs:: NamingAttributesList_T tpNames,
	   in string actionType,
	   out terminationPoint::GTP_T modifiedGTP)
        raises(globaldefs::ProcessingFailureException);

  /** 
   * <p>This service returns the GTP structure for the given GTP name(see 
   * <a href=../../../supportingDocumentation/SD1-3_BundledSNC.pdf >SD1-3 Bundled SNC overview</a>
   * for further information on GTP usage). </p>
   * <br>globaldefs::NamingAttributes gtpName: Name of the GTP to retrieve.
   * <br>terminationPoint::GTP_T gtp: The retrieved GTP.
   * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
   * EXCPT_NOT_IMPLEMENTED - Raised if EMS does not support this operation<br>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
   *  failure<br>
   * EXCPT_INVALID_INPUT - Raised when gtpName does not reference a GTP 
   *  object<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when gtpName references a GTP object that 
   *  does not exist<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
   *  lost<br>
   * <br>
   **/
   void getGTP(
	   in globaldefs::NamingAttributes_T gtpName,
	   out terminationPoint::GTP_T gtp)
        raises(globaldefs::ProcessingFailureException);


  /**
   * <p>This operation allows an NMS to request all of the GTPs (on the given  
   * Managed Element) that contain one or more TPs at the specified layer rates.
   * If there are no GTPs that match the layer constraints, an empty list is 
   * returned (see 
   * <a href=../../../supportingDocumentation/SD1-3_BundledSNC.pdf >SD1-3 Bundled SNC overview</a>
   * for further information on GTP usage). </p>
   * 
   * <p>In order to allow the NMS to deal with a large number of objects,
   * this operation uses an iterator. See
   * <a href=../../../supportingDocumentation/SD1-15_iterators.pdf >SD1-15 iterator overview</a>
   * for information on how iterators are used in this interface.</p>
   * 
   * <br>globaldefs::NamingAttributes_T managedElementName: The name of the 
   * Managed Element for which to retrieve the GTPs.
   * <br>transmissionParameters::LayerRateList_T tpLayerRateList: List of 
   * layer rates for which the GTPs are to be fetched. A GTP must contain at 
   * least one TP having one of the specified layer rates.  If the list is empty 
   * then all GTPs (of all rates) are returned.
   * <br>unsigned long how_many: Maximum number of GTPs to report in the 
   * first batch.
   * <br>terminationPoint::TerminationPointList_T tpList: First batch of 
   * GTPs.
   * <br>terminationPoint::TerminationPointIterator_I tpIt: Iterator to 
   * retrieve remaining GTPs.
   * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
   * EXCPT_NOT_IMPLEMENTED - Raised if EMS does not support this operation<br>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
   *  failure<br>
   * EXCPT_INVALID_INPUT - Raised when managedElementName does not reference a 
   *  managed element object, or the tpLayerRateList contains undefined 
   *  rates<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when managedElementName references an ME 
   *  object that does not exist<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
   *  lost<br>
   * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators 
   *  that the EMS can support has been reached<br>
   * <br>
   **/
   void getAllGTPs (
         in globaldefs::NamingAttributes_T managedElementName,
	   in transmissionParameters::LayerRateList_T tpLayerRateList,
         in unsigned long how_many,
         out terminationPoint::GTPlist_T gtpList,
         out terminationPoint::GTPiterator_I gtpIt)
        raises(globaldefs::ProcessingFailureException);
	

  /**
   * <p> The getAllGTPNames operation has the same behaviour as 
   * getAllGTPs(), except that only the GTP names are returned.</p>
   * 
   * <br>globaldefs::NamingAttributes_T managedElementName: The name of the 
   * Managed Element for which to retrieve the GTP names.
   * <br>transmissionParameters::LayerRateList_T tpLayerRateList: List of 
   * layer rates for which the GTP names are to be fetched. A GTP must contain 
   * at least one TP having one of the specified layer rates.  If the list is 
   * empty then all GTP names (of all rates) are returned.
   * <br>unsigned long how_many: Maximum number of GTP names to report in the 
   * first batch.
   * <br>globaldefs::NamingAttributesList_T nameList: First batch of GTP 
   * names.
   * <br>globaldefs::NamingAttributesIterator_I nameIt: Iterator to retrieve 
   * the remaining GTP names.
   * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
   * As for getAllGTPs().<br>
   **/
   void getAllGTPNames (
         in globaldefs::NamingAttributes_T managedElementName,
         in transmissionParameters::LayerRateList_T tpLayerRateList,
         in unsigned long how_many,
         out globaldefs::NamingAttributesList_T nameList,
         out globaldefs::NamingAttributesIterator_I nameIt)
        raises(globaldefs::ProcessingFailureException);

  /**
   * <p>The getContainingGTP operation returns the name of the GTP containing a 
   * given CTP (see 
   * <a href=../../../supportingDocumentation/SD1-3_BundledSNC.pdf >SD1-3 Bundled SNC overview</a>
   * for further information on GTP usage). If the CTP is not  
   * contained in a GTP, the gtp output parameter is left empty. </p>
   * <br>globaldefs::NamingAttributes_T ctpName: The name of the CTP for which 
   * the NMS wants to know the containing GTP.
   * <br>terminationPoint::GTP_T gtp: The name of the GTP containing the CTP. 
   * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
   *  failure<br>
   * EXCPT_INVALID_INPUT - Raised if ctpName does not reference a 
   *  terminationPoint object <br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when ctpName references an object that does 
   *  not exist<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is lost, 
   *  and communication with the ME is needed to determine the containing 
   *  GTP<br>
   * <br>
   **/
   void getContainingGTP (
         in globaldefs::NamingAttributes_T ctpName,
         out terminationPoint::GTP_T gtp)
        raises(globaldefs::ProcessingFailureException);

  /**
   * <p>This operation enables (activates, or turns on) alarm reporting 
   * for a GTP.</p>
   *
   * <p>The EMS sends an attribute value change notification in case of 
   * success.</p>
   *
   * <br>globaldefs::NamingAttributes_T gtpName: the GTP on which to 
   * activate alarm reporting. 
   * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
   * EXCPT_NOT_IMPLEMENTED - Raised if EMS does not support this service<br>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
   *  failure<br>
   * EXCPT_INVALID_INPUT - Raised when gtpName does not reference a GTP<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when gtpName references an object
   *  that does not exist<br>
   * EXCPT_UNABLE_TO_COMPLY - Raised when alarm reporting can not be enabled 
   *  for the GTP.<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to the managedElement is 
   *  lost<br>
   * <br>
   **/
   void setGtpAlarmReportingOn(
         in globaldefs::NamingAttributes_T gtpName)
        raises(globaldefs::ProcessingFailureException);


  /**
   * <p> This operation disables (deactivates, or turns off) alarm reporting on 
   * a GTP.</p>
   *
   * <p>The EMS sends an attribute value change notification in case of 
   * success.</p>
   *
   * <br>globaldefs::NamingAttributes_T gtpName: name of the GTP
   * on which to deactivate alarm reporting.
   * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
   * EXCPT_NOT_IMPLEMENTED - Raised if EMS does not support this service<br>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
   *  failure<br>
   * EXCPT_INVALID_INPUT - Raised when gtpName does not reference a GTP<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when gtpName references an object
   *  that does not exist<br>
   * EXCPT_UNABLE_TO_COMPLY - Raised when alarm reporting can not be disabled 
   *  for the GTP<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
   *  lost<br>
   * <br>
   **/
   void setGtpAlarmReportingOff(
         in globaldefs::NamingAttributes_T gtpName)
        raises(globaldefs::ProcessingFailureException);


  /**
   * <p>This service verifies the egress and/or ingress TMD state
   * of the specified TP identified by tpName.</p>
   *
   * <p>According to the requested transmission direction it checks
   * whether a TMD is assigned as egress and/or ingress TMD to the TP.
   * If this is true it first verifies the existence of the assigned TMD(s)
   * and then compares the transmission parameters of the TMD and TP,
   * and the additional TP info parameters of the TMD with the additional
   * info parameters of the TP.</p>
   *
   * <p>If a TMD parameter is not present as a TP parameter or is present but
   * with a different value, this is called a "parameter mismatch", and the TMD
   * state will take the value "mismatch".  The service returns the current
   * TMD state and all mismatched transmission or additional TP info
   * parameters of the TMD (which should mostly be none) as its output.</p>
   *
   * <br>globaldefs::NamingAttributes_T tpName:
   * the TP whose TMD assignment(s) shall be verified
   *
   * <br>terminationPoint::Directionality_T direction: the direction
   * for which the TMD assignment(s) of the TP shall be verified
   * D_SOURCE refers to the egress TMD state, D_SINK refers to the ingress
   * TMD state, D_BIDRECTIONAL refers to the egress and ingress TMD states,
   * and D_NA is not allowed
   *
   * <br>string tmdAssignmentState: the TMD state (s) of the TP
   * as determined by the verification procedure;
   * if both the egress and ingress TMD states are requested and their
   * values are different, the concatenation of the egress TMD state
   * with the ingress TMD state is returned, separated by a semicolon
   *
   * <br>transmissionParameters::LayeredParameterList_T transmissionParams:
   * a "delta" list of mismatched TMD transmission parameters, or empty. See<a 
   * href=../../../supportingDocumentation/SD1-16_LayeredParameters.pdf >SD1-16 
   * Layered Transmission Parameters</a> for more details.
   *
   * <br>globaldefs::NVSList_T additionalTPInfo: a "delta" list
   * of mismatched additional TP info parameters, or empty
   *
   * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
   * EXCPT_NOT_IMPLEMENTED - Raised if the EMS does not support this service<br>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal
   *  failure (see errorReason attribute of ProcessingFailureException())<br>
   * EXCPT_INVALID_INPUT - Raised when tpName is incorrectly formed,
   *  or one or direction value is invalid<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when tpName references an object
   *  that does not exist<br>
   * EXCPT_NE_COMM_LOSS - Raised when the communication to the managed
   *  element containing tpName is lost<br>
   * EXCPT_UNABLE_TO_COMPLY - Raised when the EMS is unable or unwilling to 
   *  execute the request<br>
   * <br>
   **/
   void verifyTMDAssignment(
         in globaldefs::NamingAttributes_T tpName,
         in terminationPoint::Directionality_T direction,
         out string tmdAssignmentState,
         out transmissionParameters::LayeredParameterList_T transmissionParams,
         out globaldefs::NVSList_T additionalTPInfo)
        raises (globaldefs::ProcessingFailureException);

  /**
   * <p>This operation has exactly the same behaviour as 
   * getAllCrossConnections(), but instead returns only fixed Cross Connection 
   * object structures. See <a href=../../../supportingDocumentation/SD1-36_SNCTypes.pdf >SD1-36 
   * Subnetwork Connection Types</a> for an explanation of fixed SNCs.</p>
   *
   * <p>A cross connection is identified as fixed using additional information. 
   * See <a href=../../../supportingDocumentation/SD1-1_additionalInfoUsage.pdf >SD1-1 
   * Additional Information Usage</a> for detail on additional information
   * for SNCs, cross connections and TPs.</p>
   *
   * <p>In order to allow the NMS to deal with a large number of objects,   
   * this operation uses an iterator. See   
   * <a href=../../../supportingDocumentation/SD1-15_iterators.pdf >SD1-15 iterator overview</a>   
   * for information on how iterators are used in this interface.</p>
   * 
   * <br>globaldefs::NamingAttributes_T managedElementName: Name of the 
   * Managed Element for which to retrieve CCs.
   * <br>transmissionParameters::LayerRateList_T connectionRateList: List of 
   * rates for which to retrieve CCs. This must not be an empty list. In this 
   * case an INVALID_INPUT exception is thrown.
   * <br>unsigned long how_many: Maximum number of CCs to report in the 
   * first batch.
   * <br>subnetworkConnection::CrossConnectList_T ccList: First batch of CCs.
   * <br>subnetworkConnection::CCIterator_I ccIt: Iterator to retrieve 
   * remaining CCs.
   * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
   * EXCPT_NOT_IMPLEMENTED - Raised when EMS does not support this service<br>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
   *  failure<br>
   * EXCPT_INVALID_INPUT - Raised if connectionRateList is empty or contains
   *  invalid rates, or if managedElementName does not reference a managed 
   *  element.<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when managedElementName references an ME 
   *  object that does not exist<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
   *  lost<br>
   * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators 
   *  that the EMS can support has been reached<br>
   * <br>
   **/
   void getAllFixedCrossConnections(
         in globaldefs::NamingAttributes_T managedElementName,
         in transmissionParameters::LayerRateList_T connectionRateList,
         in unsigned long how_many,
         out subnetworkConnection::CrossConnectList_T ccList,
         out subnetworkConnection::CCIterator_I ccIt)
        raises(globaldefs::ProcessingFailureException);

  /**
   * <p> The operation is used to retrieve fixed connection schemes related to 
   * normal and inverse multiplexing. 
   * See <a href=../../../supportingDocumentation/SD1-36_SNCTypes.pdf >SD1-36 
   * Subnetwork Connection Types</a> for an explanation of fixed SNCs.</p>
   *
   * <p>A cross connection is identified as fixed using additional information. 
   * See <a href=../../../supportingDocumentation/SD1-1_additionalInfoUsage.pdf >SD1-1 
   * Additional Information Usage</a> for detail.</p>
   *
   * <p>The operation takes as an input a TP and if this TP may be or is 
   * involved in a multiplexing or inverse multiplexing scheme, it will 
   * report:<ul>
   * <li>The TP containing the fixed layer.</li>
   * <li> the list of potential fixed cross connects that will exist if the 
   * containing TP's clientConnectivity or serverConnectivity is set to 
   * "Connected" (i.e. If the containing TP is set to multiplexing or inverse 
   * multiplexing).</li>
   * </ul><br></p> 
   * 
   * <p>If the clientConnectivity (resp. serverConnectivity) of the TP is 
   * currently set to "Connected", the potentialCCList matches the list of 
   * active fixed cross connects that involve its client TPs (resp. server 
   * TPs).</p>
   *
   * <p>If the TP client layer (resp. server layer) is always fixed cross 
   * connected (hard-wired), the potentialCCList always matches the list of 
   * active fixed cross connects that involve the client TPs (resp. server 
   * TPs).</p>
   *
   * <br>globaldefs::NamingAttributes_T inputTP: any TP of the ME. The 
   * operation will return the multiplexing or inverse multiplexing scheme in 
   * which this TP is involved. The input TP may be either the containing TP or 
   * one of the end TPs of the portentialCCList.
   * <br>globaldefs::NamingAttributes_T ContainingTP: The TP supporting the 
   * attribute clientConnectivity or serverConnectivity
   * <br>globaldefs::NamingAttributes_T PortentialCCList: the list of fixed 
   * Cross Connect of that multiplexing scheme, i.e. the list of cross connects  
   * that will exist when the containing TP clientConnectivity or 
   * serverConnectiivty is set to "Connected". The A_end TPs of the cross 
   * connects should be the low order TPs that can be flexibly cross connected, 
   * and the Z_end TPs the TP client of the high order TP. The list of cross 
   * connect does not take any specific order. If there are no potential fixed 
   * cross connects and empty list is returned.
   * <br><b>Raises</b> globaldefs::ProcessingFailureException <br>
   * EXCPT_NOT_IMPLEMENTED - Raised if the EMS does not support this service<br>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal 
   *  failure<br>
   * EXCPT_INVALID_INPUT - Raised if inputTP does not reference a TP.<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when inputTP references a TP 
   *  object that does not exist<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is 
   *  lost<br>
   * EXCPT_UNABLE_TO_COMPLY - Raised when TP is neither a higher order TP that 
   *  supports fixed multiplexing nor a lower order TP that supports fixed 
   *  inverse multiplexing<br>
   * <br>
   **/ 
   void getPotentialFixedCCs(
         in globaldefs::NamingAttributes_T inputTP,
         out globaldefs::NamingAttributes_T ContainingTP,
         out globaldefs::NamingAttributes_T potentialCCList)  
        raises(globaldefs::ProcessingFailureException);


    };

};

#endif


